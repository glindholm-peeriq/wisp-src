						 	qawisp32.lis  
							Updated: 08/10/92
	WISP QA CHECKLIST
	=================

	QA Engineer:  _________________________________	   Date __/__/__

	Platform:     _________________________________

	Version:      _________________________________

	Problems 
	detected: (1)_____________________________________________________

		  (2)_____________________________________________________

		  (3)_____________________________________________________

		  (4)_____________________________________________________

		  (5)_____________________________________________________

		  (6)_____________________________________________________

		  (7)_____________________________________________________

		  (8)_____________________________________________________

		  (9)_____________________________________________________

		  (10)____________________________________________________


	PURPOSE:	This QA checklist is to be used to test and verify
			all functionality of WISP.

	WHEN USED:	This QA checklist is used everytime WISP is
			ported to a new platform and everytime a new
			release is re-ported to a platform.

+			The items that comprize a mini-test are marked
+			with a plus sign (+) in column one.

	INSTRUCTIONS:	1) Fill in the above information.

			2) Do each action in sequence and check it off
			   as it is done.

			3) If any functionality is not working number it
			   and note it on this checklist (above) and report
			   it thru JOBTRACK (or verify it is already in 
			   JOBTRACK.)
			   Use the following codes beside the item:
				FAIL	- Not Working as expected
				ABORT	- Causes program to ABORT
				MISS	- Known missing functionality
				N/A	- Not Applicable to environment
				ENHC	- Enhancements needed

			4) When completed turn in this checklist for
			   record of testing.


#####################  This page is for UNIX only  ########################

+	PREREQUESITE

	___	Port WISP to this machine following the steps outlined in
		the document "portunix.lis".


+	SET UP FOR WISP QA TESTING.
	
	___	Login to 2 windows/terminals as 2 DIFFERENT userids.

	___	Set the environment variable $WISP to point to the WISP
		directory.
		NOTE:	The $WISP variable must be set for the whole
			testing procedure.

			$ WISP=/usr2/wisp 
			$ export WISP

	___	Add the QA installed WISP (wisp.QA) to your $PATH.  This 
		will ensure you are testing the correct programs.

			$ PATH=$WISP/wisp.QA/bin:$PATH
			$ export PATH

	___	Set $WISPGID if not running the Bourne Shell.

		ksh 	$ WISPGID=$$ export WISPGID
		csh 	$ setenv WISPGID $$

	___	Change directory to your "test" dir based on the COBOL you
		are using.

		ACU	$ cd $WISP/src/testacu
		MF	$ cd $WISP/src/testmf

	___	Verify the "startup" file is correct then run it to setup
		environment variables.  This will set your $WISPCONFIG plus
		COBOL specific variables.  It will also set $QA to point
		to your test directory.

		ACU	$ vi startup.acu
			$ . startup.acu

		MF	$ vi startup.mf
			$ . startup.mf

	****
	****    THE ABOVE STEPS MUST BE DONE EVERYTIME YOU RE-START.
	****


+	BUILD SAMPLE

	___	Copy in the rules file

		ACU	$ cp $WISP/wisp.QA/acu/acu.rules .
		MF	$ cp $WISP/wisp.QA/mf/mf.rules .

	___	Build the SAMPLE programs.

		ACU	$ make -f sampleacu.umf
		MF	$ make -f samplemf.umf
		LPI	$ make -f samplelpi.umf

	___	Build the COBOL "link" files.

		ACU	$ cp $WISP/wisp.QA/acu/aculink.wcb .
			$ cp $WISP/wisp.QA/acu/acuusing.cob .
			$ wisp aculink
			$ ccbl -da4 -o ACULINK aculink.cob
			$ ccbl -da4 -o ACUUSING acuusing.cob

		MF	$ cp $WISP/wisp.QA/mf/mflink.cob .
			$ cob mflink.cob
			$ cp mflink.int MFLINK.int

	___	Build DISPRINT.

		ACU	$ cp $WISP/wisp.QA/etc/disprint.wcb .
			$ cp $WISP/wisp.QA/etc/disprntacu.umf .
			$ make -f disprntacu.umf

		MF	$ cp $WISP/wisp.QA/etc/disprint.wcb .
			$ cp $WISP/wisp.QA/etc/disprntmf.umf .
			$ make -f disprntmf.umf


+	SETUP $WISPCONFIG DIRECTORY

	___	Take a copy of the SHIP config directory.
			$ mkdir $WISPCONFIG
			$ cd $WISP/wisp.QA/config
			$ find . -print|cpio -pcvd $WISPCONFIG
			$ cd $WISPCONFIG

	___	Setup $WISPCONFIG/LGMAP. (Use supplied template files.)

		ACU	$ cp $QA/lgmap.acu LGMAP
		MF	$ cp $QA/lgmap.mf  LGMAP

			$ vi LGMAP		- finish setup

	___	Setup $WISPCONFIG/wrunconfig

		ACU	$ cp $QA/wrunconfig.acu wrunconfig
		MF	$ cp $QA/wrunconfig.mf  wrunconfig

	___	Setup $WISPCONFIG/OPTIONS

			$ vi OPTIONS
				- uncomment IDSIPRINTON

	___	Setup $WISPCONFIG/ACUCONFIG  (ACUCOBOL ONLY)
		Take a copy of the cblconfig file from the ACUCOBOL
		directory then edit it to create ACUCONFIG.  Substitute
		the ellipses (...) with the actual locations.

			$ cp .../acucobol/cblconfig ACUCONFIG
			$ vi ACUCONFIG

				FILE-STATUS-CODES 74
				CODE-PREFIX .../src/testacu .

	___	Setup $WISPCONFIG/wsysconfig

			$ wsysconf

	___	Check your setup with WDIAG

			$ wdiag

	___	Create directory for QA

			$ cd $QA
			$ mkdir volrun volin
			$ mkdir volrun/librun volrun/libexe volin/libin


+	SETUP THE UNIX PRINT QUEUE

		You will need to be ROOT (su) to do this step.
		NOTE:	There is no way to setup a "QA" version of the 
			print queue, you are going to setup the real thing.
			So if others are using the machine be very careful.
			We will run these out of "wisp.QA".

	___	Create the directory and copy in the sample def files.

			$ su

			$ mkdir /usr/spool/iprint
			$ cd /usr/spool/iprint
			$ cp $WISP/wisp.QA/etc/ilpdef.sam   ilpdef
			$ cp $WISP/wisp.QA/etc/prtdef.sam   prtdef
			$ cp $WISP/wisp.QA/etc/formdef.sam  formdef
			$ cp $WISP/wisp.QA/etc/classdef.sam classdef

	___	Edit the definition file so they are correct for this
		machine.
			ilpdef
			prtdef
			formdef
			classdef

	___	Setup and run idaemon from "wisp.QA".

			$ cd $WISP/wisp.QA/bin
			$ chown root idaemon ishut
			$ chmod u+s idaemon ishut
			$ ./idaemon

	___	Check for errors in the print queue setup.

			$ cat /usr/spool/iprint/errs



#####################  This page is for VMS only  #########################

+	PREREQUESITE

	___	Port WISP to this machine following the steps outlined in
		the document "portvms.lis".


+	SET UP FOR WISP QA TESTING.
	
	___	Login to 2 windows/terminals as 2 DIFFERENT userids.

	___	Set your directory default to the QA directory.

			$ SET DEFAULT USER$DISK:[WISPQA]

	___	Change WISP$ROOT to point the the QA directory

			$ ED [.COM]WISP_INIT.COM
			change  WISP$ROOT USER$DISK:[WISPQA.]
			change  /SYSTEM to /PROCESS

	___	Set the SYMBOLS and LOGICALS (then check them)

			$ @[.COM]WISP_INIT
			$ @[.COM]WISP_SYMBOLS
			$ SHOW LOG WISP$ROOT
			$ WISP WHODUNIT

		****
		****    THIS STEP MUST BE DONE EVERYTIME YOU RE-START.
		****	(The RESTART_QA.COM is a short-hand method.)
		****

			$ SCS INIT WISP SAMPLE
			$ @SRC:RESTART_QA.COM


+	BUILD SAMPLE

	___	Build SAMPLE and the QA programs

			$ SET DEFAULT USER$DISK:[WISPQA]
			$ SCS INIT WISP SAMPLE
			$ SCS BUILD QA

		This step also builds the the QA volumes and sets up
		the LOGICALS.  This is done by running DEFS_WISPQA.COM.

+	SETUP THE RUNTIME ENVIRONMENT

	___	Define the logical volumes

			$ SCS INIT WISP SAMPLE
			$ @SRC:DEFS_WISPQA.COM

		NOTE:   This step is done when you build SAMPLE but if you
			are just running a pre-built SAMPLE you need to
			do it along with INIT_WISP and INIT_SYMBOLS.
			(or use RESTART_QA.COM which does all three steps.)


+	SETUP WISP$CONFIG FILES

	___	VMS:	Check WISP$CONFIG:

			TTMAP.DAT	- Add your terminal id
			PQMAP.DAT	- Need "A"
			LPMAP.DAT	- Need "A", "B", and "Z"
			MTMAP.DAT
			OPTIONS.DAT
			WISPMSG.DAT



################  This page is for both UNIX and VMS  ####################


+	ARRANGE COMPONENTS TO PREPARE FOR QA TEST

		*** Create separate executables ****
	___	UNIX: 	Copy SAMPLE   to SAMPLE2  in LIBRUN on VOLRUN
	___	UNIX: 	Copy TRIGGER  to TRIGGER2 in LIBEXE on VOLRUN
	___	UNIX: 	Copy TRIGGER  to TRIGGER3 in $HOME/bin

	___	UNIX:Copy a large text file with col=132 (i.e vwang.c) to 
			FILE=XYZ LIB=LIBIN VOL=VOLIN 
			(VMS:set extension to .LIS)


+	SETUP DEFAULT USAGE CONSTANTS

	___	Run "wusage shell" and set your USAGE CONSTANTS as follows

			INDIR	= LIBIN		INVOL	= VOLIN	
			OUTDIR	= LIBOUT	OUTVOL	= VOLOUT
			RUNDIR  = LIBRUN	RUNVOL	= VOLRUN
			SPOOLDIR= (blank)	SPOOLVOL= VOLSPL
			WORKDIR			WORKVOL = VOLWRK


+	First check-out general functionality.

	___	VMS:	$ SET DEFAULT SOURCE:[TESTVMS]
		UNIX:	$ cd $QA

	___ 	Run SAMPLE

	___	REFRESH (^w)
	___	HELP-KEY (^e)
			Look for the following info:
			__  Workstation number
			__  Date and time
			__  Username
			__  System name (UNIX only)
			__  Progam: SAMPLE
			__  Screen: MAIN-SCREEN

	___	(32) Copyright Screen.
		Verify the Release version number.

	___	(2) SET File Usage Constants.
		Verify that they are set as entered above.
		SPOOLDIR and WORKDIR should have been generated.

	___	Change SPOOLDIR = "LIBSPOOL" for rest of testing.

	___	(3) SET Print Mode defaults.
		PRNTMODE = P
		PRTCLASS = B
		FORM_NUM = 000
		Change the values then test the PF1 and RETURN options.

	___	(4) SET Submit Procedure defaults.
		JOBQUEUE = R
		JOBCLASS = A
		
	___	UNIX: (5) Manage FILES/LIBRARIES

	___	AIX:  (6) Manage SYSTEM

	___	(14) PRINT PROGRAM Screen.
		(15) PRINT COMMAND Screen.
		Check the printouts for correctness.
		Files are id#### LIBSPOOL VOLSPL.
		Verify the file	has been submited to a print queue.

	___	VMS:Queue Management
		Try all function keys and go into a queue.
		Try help screen in queue menu as well as queue job menu.

	___	UNIX: (7) Manage PRINT QUEUE
			If option (7) does not appear on the help screen, 
			edit the OPTIONS file in the WISPCONFIG directory 
			and uncomment the line:
				IDSIPRINTON

		(9) Use UTILITIES
	___	(2) DISPLAY a file

		(9) Use UTILITIES
	___	(3) EDIT a file

		(9) Use UTILITIES
	___	(4) DISPRINT
 
		(10) Configure TERMINAL.		
	___	(2)  PSEUDO Blank Characteristics.

		(10) Configure TERMINAL.		
		(3)  CURSOR Characteristics.	
	___	Auto tab flag  = Y  	At field end should tab to next
				 N	At field end should stop
	___	Auto move flag = Y	If out of field goto next field
				 N	If out of field beep	
	___	Menu pick cursor = Y	Cursor On (Monkey bar)
				   N	Cursor Off -- only on terminals that
					you can turn off the cursor.
		
		(10) Configure TERMINAL.		
	___	(4)  SCREEN Characteristics.

	___	(11) Enter COMMANDS
		UNIX: Type "exit" or "^d"  when finished, to return.
		VMS:  Type "logoff".

	___	(13) SAVE environment.  "YES" and no filename.
		VMS: Save to WISP$CONFIG:PERSONALITY.QA

	___	(16) CANCEL Processing




	Do SAMPLE.WCB tests


		Run SAMPLE

	01) COBLINK  		Does a LINK type " " and if file is not
				found will then do a LINK of type "S".

				On UNIX so be sure your PATH includes your 
				current dir.

+	___	COBLINK to TRIGGER  (PF-16)	(Type=" ";current dir)
	___	COBLINK to SAMPLE2  (PF-16)	(Type=" ";RUNLIB, RUNVOL)
	___	COBLINK to TRIGGER3 (PF-16)	(Type="S")


	02) MOVE WITH CONVERSION
					This converts a text string to a
					numeric then displays it.
					Test with the following values:
	___	+123.45
	___	.12345
	___	12345-
+	___	-12.34
	___	12-34		(ERROR)
	___	XYZ		(ERROR)
		(PF16 to EXIT)


	06) COBOL TESTS

	___	1) DISPLAY VERB.	Should display a message with a
					"Press RETURN to proceed" at bottom.

+	___	2) RETURN-CODE.		Enter value then exit program and
					retrieve it;
		   			UNIX: wretcode   
					VMS:show symb $W_RETURN_CODE

	___	3) SORT VERB.		Will sort a small file by the 
					SORT verb, then display both
					the unsorted & sorted file.
					Verify the sorted file is sorted
					by TYPE then DATE.

	___	4) CONDITIONAL TEST.	WISP_CODE conditions.  Press return.

+	___	5) ACCEPT VERB.		Enter the following (TAB to fields):
					COMPANY  = This test is a trickler.
					YEARCODE = 987654321
					ACCESSCO = abc

	___	COMPANY should be 20 bytes long.  Press return.

	___	YEARCODE should be "4321".  Press return.

	___	ACCESSCODE should be "a".  Press return.




	03) FILE I/O TESTS	(QAFILEIO)

		In this section we are going to test all the file I/O
		functionality.

		FILE-A tests.		Assume these work if no errors
					are reported.

+	___	01) CREATE FILE-A AND WRITE IT		(no message)
					Should create AFILE LIBOUT VOLOUT
+	___	04) DELETE RECORDS FROM FILE-A
+	___	01) CREATE FILE-A AND WRITE IT
			Should get a PF3 getparm screen.
			Change FILE from AFILE to AAA and press Enter.
					Should create AAA   LIBOUT VOLOUT

		SEQUENTIAL FILE tests.

+	___	06) CREATE A SEQUENTIAL FILE 
					Leave the lib and vol blank.
					Should create SEQFILE LIBOUT VOLOUT
		    PF16 back to menu.
	
	___	22) OPEN EXTEND SEQUENTIAL (should be no getparm)
	___	24) CLOSE SEQUENTIAL	   (no message)
	___	23) OPEN OUTPUT SEQUENTIAL (getparm - Press PF3)
	___	24) CLOSE SEQUENTIAL	   (no message)

+	___	06) (again): At PF3 option FILE=SEQFILE1
		    PF16 back to menu.

	___	06) (again): Use FILE=##AB to test temp filename generation.
 		    Should use (worklib) VOLWRK. 
	___	Do the above twice each time setting FILE=##AB to test temp
 		    filename sequencing AB0000 AB0001 AB0002
	___	Once more this time don't change FILE, it should NOT give
		    you a file-getparm "PF3 to continue" because in WORKLIB.
		    PF16 back to menu.

+	___	25) WRITE SEQUENTIAL	Enter any value 
					Should ERROR getparm  (85) [48][02]
							      (74) [91][02]
		PF16 to EXIT program.

+	___	UNIX: 	echo $?			Should be 16
			wretcode		Should return 16



	Run SAMPLE and 3) FILE I/O TESTS

		FILE-B tests.	These test all the INDEXED file I/O operations.
				Check FILE-B-STAT field after each operation.

	___	07) CREATE FILE-B	Hit <RETURN> 	(file status 00)
					Should create BFILE LIBOUT VOLOUT
	___	08) OPEN FILE-B I-O	Hit <RETURN>	(file status 00)

				Now, enter test values for these fields.
				    KEY  ALT1 ALT2 VALUE-1
	___	11) WRITE FILE-B    AAAA AAAA AAAA 1
	___	    WRITE FILE-B    BBBB BBBB BBBB 2
	___	    WRITE FILE-B    CCCC CCCC CCCC 3
	___	    WRITE FILE-B    ABBB AAAA BBBB 4    (file status 02)
	___	    WRITE FILE-B    AABB AAAA BBBB 5    (file status 02)
	___	    WRITE FILE-B    AAAB AAAA BBBB 6    (file status 02)
	___	    WRITE FILE-B    EEEE BBBB AAAA 7    (file status 02)
		    PF16 back to menu.

			For this one, enter value in FILE-B-KEYS-ALT 
			field on the second half of the screen.
	___	18) WRITE ALT       DDDDCCCCBBBB   8    (file status 02)

				    KEY  ALT1 ALT2 VALUE-1
	___	12) READ FILE-B     EEEE           ( 7	file status 00)
	___	    READ FILE-B     XXXX	   ( 	file status 23)
	___	13) READ ALT-1           AAAA      ( 1	file status 02)
	___	    READ ALT-1           BBBB      ( 2	file status 02)
	___	14) READ ALT-2                CCCC ( 3	file status 00)
	___	10) CLOSE FILE-B		       (file status 00)

	___	08) OPEN FILE-B I-O	Hit <RETURN>   (file status 00)
	___	17) READ FILE-B NEXT	<RETURN>  9 times you should get the
					records back in primary key order 
					1,6,5,4,2,3,8,7 then file-status 10

	___	26) START FILE-B    CCCC
	___	17) READ NEXT 		<RETURN> 4 times: 
					3, 8, 7, then file-status 10.

	___	28) START FILE-B ALTKEY-1   altkey-1 = BBBB (Hit <RETURN>)
	___	17) READ FILE-B NEXT  	<RETURN> 5 times you should get the
					records back in alt-1 key order
					2,7,3,8 then file-status 10.
	___	10) CLOSE FILE-B	Hit <RETURN>  (file status 00)

	___	15) OPEN FILE-B INPUT	Hit <RETURN>  (file status 00)
	___	17) READ NEXT		Should get 1
	___	11) WRITE FILE-B KEY=XXXX.  		        (85) [48]
								(74) [90][01]
				File status WRITE NOT ALLOWED
				There should be an ERROR getparm.
				We have declaratives but this is a BAD error.
		PF16 to EXIT program.

	Run SAMPLE and 3) FILE I/O TESTS

	___	15) OPEN FILE-B INPUT   At FILE getparm, set LIBOUT and VOLOUT
	___	15) OPEN FILE-B INPUT   Error-getparm  		(85) [41]
								(74) [92][00]
		PF16 to EXIT program.


	Run SAMPLE and 3) FILE I/O TESTS

		RECORD & FILE LOCKING TESTS
	
		FILE-B record and file locking tests. Start two windows
		running QAFILEIO. These will be referred to a <W1> & <W2>.

		**** NOTE **** If you don't have 2 windows for this
		test then only do the items marked with 3 asterisks (***).

	___	<W1> 08) OPEN FILE-B I-O  File-getparm LIBOUT VOLOUT
	___	<W2> 08) OPEN FILE-B I-O  File-getparm LIBOUT VOLOUT
					  File-getparm FILE LOCKED
	___	<W1> 10) CLOSE FILE-B
	___	<W2> RETURN to retry OPEN I-O
	___***	<W1> 09) OPEN FILE-B SHARED file-getparm FILE LOCKED

	___	<W2> 10) CLOSE FILE-B
	___	<W1> RETURN to retry OPEN SHARED
	___	<W2> 09) OPEN FILE-B SHARED  (success both have it opened)

	___***	<W2> 20) READ HOLD & REWRITE  key=AAAA (Record is now locked)
	___	<W1> 12) READ                 key=AAAA (should succeed)
	___	<W1> 19) READ HOLD            key=BBBB (should succeed)

	___***	<W1> 21) READ HOLD & DELETE   key=AAAA (should wait)
	___	<W2> Modify B-VALUE-2="NEW TEXT HERE"
		     RETURN to rewrite	  <W1> 	Should get modified record
	___	<W2> 19) READ HOLD            key=AAAA (should wait)
	___	<W1> RETURN to delete     <W2> 	file-status 23 NOT FOUND

	___	<W1> 19) READ HOLD	      key=BBBB (should succeed)
	___	<W2> 19) READ HOLD	      key=BBBB (should wait)
	___***	<W1> 29) FREE ALL         <W2> 	Should now get record
	___	<W2> 29) FREE ALL		No message

	___	<W1> 19) READ HOLD            key=BBBB	(should succeed)
	___***	<W2> 27) READ TIMEOUT         key=BBBB 
					Should wait 5 secs then come back
					with **** TIMEOUT **** filestatus 
					REC LOCKED (92 or 99 or 9D)

		Next we try a non-timeout this is tricky and you need to
		be fast. <W1> has BBBB locked now, <W2> is going to try
		to read and lock BBBB, <W1> will read and lock CCCC
		this will free BBBB and allow <W2> to lock it.

	___	<W2> 27) READ TIMEOUT key=BBBB **** don't press return ****
	___	<W1> 19) READ HOLD    key=CCCC **** don't press return ****
	___	<W2> press RETURN quickly <W1> press RETURN
		Window <W1> should get CCCC then a moment later <W2> should
		get BBBB without a TIMEOUT.

	___***	<W1> 19) READ HOLD   key=AAAA INVALID KEY 23 (was deleted)
		This should unlock CCCC.
	___	<W2> 19) READ HOLD   key=CCCC 	(should succeed)
	___***	<W2> 10) CLOSE FILE-B   	(should unlock CCCC)
	___	<W1> 19) READ HOLD   key=CCCC 	(should succeed)
	___	<W1> 10) CLOSE FILE-B

		We are finished the lock tests, EXIT from <W2>.


	QAFILEIO - Screen 2

		32) NEXT SCREEN

	___	01) SEQ/DYN LOGGING	Should give three screens, an OPEN
					WRITE and CLOSE. Each screen shows
					the file status, 05 is fine for
					the OPEN.
					Run three times waiting a minute
					between each one. This will write
					three timestamps out to the file.
	___	Now look at the file created with DISPLAY from HELP screen.
		file=@TRNSLOG lib=@LOGFIL@ vol=VOLOUT  (On VMS ext=.DAT)

		(Set PRINTMODE = Keep)
	___	02) OPEN OUT PRINT WRITE CLOSE
					Leave lib & vol blank, it should
					use LIBSPOOL and VOLSPL.
	___	Now look at the file created with DISPLAY from HELP screen.
		It was written with AFTER ADVANCING PAGE and 5 LINES.
		file=PRTFILE lib=LIBSPOOL vol=VOLSPL  


	___	02) OPEN OUT PRINT WRITE CLOSE (again)
					Change file=PRTFILE2.

	___	03) OPEN OUTPUT PRINT FILE	(PF3 to continue)
	___	04) CLOSE PRINT FILE		(no message)

	___	05) OPEN EXTEND PRINT FILE	(NO PF3, it's EXTEND)
	___	04) CLOSE PRINT FILE		(no message)

	___	06) OPEN EXT PRINT WRITE CLOSE	(no message, it's EXTEND)

	___	07) SUBS SCREEN/PRINT EXTEND	
			This one uses the "SCREEN" and "PRINT" subs to 
			create a print file then extend it.  You will see
			a screen image and there should be a line following
			it that has a name and timestamp.

	___	13) CREATE A LARGE FILE	  (This may take up to 10 min on VMS)
			START  __:__:__:__
			END    __:__:__:__     TIME (min:sec)  __:__

		PF16 to EXIT FILE I/O TESTS


	04) SCREEN I/O TESTS (QASCREEN)

		This section tests all the screen I/O functionality.

+	___	01) DISPLAY A COMPLEX SCREEN.
	___	Test the NEWLINE (^fn) & BACKTAB (^f^i) key. These keys
		are also mapped on the VT220 to NEXT-SCRN PREV-SCRN.

	___	02) TRY THE PF KEYS.  		try all PF keys 1-32
         
		03) PIC ZZ AND MISC.

		The fields on the screen will accept Alpha, Alpha-Numeric,
		or Numeric input based on the picture clauses displayed.

		Invalid values will cause the field to blink and must be
		corrected before the screen will be accepted.  After each 
		screen is accepted, press ENTER again to test the next set,
		press PF16 to exit when done.

		Numeric fields should blink if picture does not allow value.
		If fields blink, change the values and press return again.
		Enter each of the following values into every Numeric field:

	___	"0"

	___	"1" 

	___	"-1"   (Try   "1 CR" and "1 DB" where appropriate)

	___	"9.9"

	___	Enter a value to fill the field, examples:
			PIC ----.--		-123.45
			PIC ZZZ/ZZ/ZZZZ		123456789 
			PIC ZZZZ,ZZZ,ZZZ,ZZZ	1111222333444

	___	Alpha and Alpha-Numeric fields.
		To test the Alpha and Alpha-Numeric fields, enter both valid
		and invalid Letter/Number combinations.  

+	___	06) TEST REWRITE TO CRT. 	A message should flash
       
	___	08) TEST COMPLEX MUTIPLE DIMENSIONS. (3D table)
					Just see that it displays.

		11) TEST MONKEY BAR MENU.  
	___	    TAB KEY should hit all fields
	___	    SPACEBAR should hit only menu positions   
	___	    "F" "T" "S" should take you to menu positions
	___	    ENTER at each of the menu positions should give four 
		    different screens (this tests the cursor position clause)
	___	    Move cursor off first menu position then PF16 to EXIT
		    the cursor should position back to the first menu 
		    position.
		    RETURN to continue with EXIT.

	___	12) COLUMN TEST. 	Should display column twice.
			Test the RANGE clause.
				-999   *	(* = should fail)
				-100   *
				-99
				0
				100
				999
				1000   *
				99999  *
				(blank)
                 
+		13) DISPLAY AND READ TOTAL TEST.  This tests all the clauses
		    of DISPLAY & READ. Need to run it several times.
	___	    Press PF1	message NO MODS WERE MADE ON THIS SCREEN
	___	    Rerun PF2 	message NO MODS WERE MADE ON THIS SCREEN
	___	    Rerun PF3	message ON-PFKEY: PFKEY 03 WAS PRESSED
	___	    Rerun PF4	message ON-PFKEY: PFKEY 04 WAS PRESSED

	___	    Rerun ENTER, PF5, PF16 should beep
	___	    Enter "NO " PF1  should end with no message
	___	    Rerun enter "YES" PF4 
				message ON-PFKEY: PFKEY 04 WAS PRESSED
	___	    Rerun should still say "NO "
	___	    Enter "XXX" PF1 & PF2 field should blink
	___	    PF3 should end with 
				message ON-PFKEY: PFKEY 03 WAS PRESSED
 
		**** NOTE ****	First change your pseudo blank to a 
				character in "N" normal rendition. 
				(something other then underline)


		15) REWRITE & READ OF CRT.   
		This does 4 rewrites & reads of the screen. The first 2
		are with the MODIFIABLE clause, the second 2 with ALTERED.
		Should be pseudo blanks in the first half of the last 2
		lines only.

		**** NOTE ****  Do not type over all of the pseudo blanks
				as we need some on the screen to test
				how the read handles them.

	___	Enter stuff on all modifiable lines. This should test all
		of the FAC's BLINK BOLD HIDDEN UNDERLINE DIM
	___	"ENTER" the pseudo blanks should be replaced with spaces.
	___	"ENTER" the pseudo blanks are back. 
	___	"ENTER" the pseudo blanks are NOT replaced with spaces.
		"ENTER" to end
     
+		17) ROW REWRITE & READ 	Test ROW oriented screen I/O
					This will write over top of the
					existing screen.
	___	At row 10 **** REWRITE TEST *** Cursor should be positioned
		at row 10 col 2.
	___	TAB should take you to row 11 col 5. This should be 
		BRITE MODIFIABLE enter text here.
	___	ENTER.
 		Row 11 should be duplicated on row 12 but DIM NO-MOD.
	___	ENTER.
		Should BEEP Row 16 message ALARM & CENTER (blinking+brite), 
		cursor should be centered on screen row 12 col 40. 
	___	ENTER.
		Cursor should postion row 1 col 40 with no other changes
		on the screen (write order-area only test). 
	___	ENTER 
		Screen should be repainted.

	___	18) MULTIPLE COLUMNS		Should display 4 double cols


	___	19) EMBEDDED FAC TEST
		    Type over the +++++ then press return. What you typed
		    should remain on screen.
		    Press return again to exit.

		PF16 to exit SCREEN tests


	05) WANG USERSUBS TESTS (QASUBS)

		This section tests all of the Wang USERSUBS.


		01) READFDR	Try it with indexed & sequential files.

		Try with an indexed file (COMPRESSED)
		set FILE=BFILE   LIBRARY=LIBOUT VOLUME=VOLOUT

						     	UNIX	VMS
	___	Function  CD	PF2 (creation date)
	___	Function  FT	PF2 (file type)       	(I)	(I)
	___	Function  RC	PF1 (record count)    	(7)	(1)
				(Micro Focus FHISAM files don't support RC)
	___	Function  RL	PF1 (record length)   	(92)	(92)
	___	Function  RT	PF2 (record type)     	(C)  NOT SUPP & 40
	___	Function  XX    PF1   should get NOT SUPPORTED & retcode 40

		Try with an indexed file (Not COMPRESSED)
		set FILE=AAA    LIBRARY=LIBOUT VOLUME=VOLOUT

+	___	Function  RC	PF1 (record count)    	(199)	(1)
+	___	Function  RL	PF1 (record length)	(84)	(84)

		Try with an EMPTY indexed file
		set FILE=AFILE    LIBRARY=LIBOUT VOLUME=VOLOUT

+	___	Function  RC	PF1 (record count)    	(0)	(0)
+	___	Function  RT	PF2 (record type)	(F)	NOT SUPP

		Try with a sequential file
		set FILE=SEQFILE1 LIBRARY=LIBOUT VOLUME=VOLOUT

						     	UNIX	VMS
+	___	Function  FT	PF2 (file type)       	(C)	(C)
+	___	Function  RC	PF1 (record count)    	(1)	(1)
+	___	Function  RL	PF1 (record length)   	(256)	(20)
+	___	Function  BS	PF3 (Byte Size)		(120)
+	___	Function  RT	PF2 (record type)     	(V)  	NOT SUPP

		Try with an EMPTY sequential file
		set FILE=SEQFILE LIBRARY=LIBOUT   VOLUME=VOLOUT

	___	Function  RC	PF1 (record count)    	(0)	(0)

		Try with a non-existant file
		set FILE=XEQFILE LIBRARY=LIBOUT    VOLUME=VOLOUT

	___	Function  RC	PF1   should get return code 20
	___	Function  XX	PF1   should get return code 20


		UNIX: Try an UPPERCASE file name.
		set FILE=SAMPLE2  LIBRARY=LIBRUN   VOLUME=VOLRUN

	___	Function  CD	PF2 (creation date)



		02) FIND	Your going to run this several times.
				Be sure to reset the counter to 10 each time
				unless told otherwise.
				A "?" matches any number of characters
				a "*" matches one character.
				(On VMS you cannot use wildcards in the
				volume name.)
				A blank in FILE means find libraries.
				A blank in FILE & LIB means find volumes.
				COUNTER is the number returned.
				FILE COUNT is the total number found.
				STARTER is where to start returning from
				out of total number.

			****	Verify all these results against the disk.

		FILE	LIBRARY	VOLUME  START COUNTER	FILE COUNT (total)
		======  ======= ======  ===== =======	==========
	___	?	LIBOUT	VOLOUT 	1	10	(6)
+	___	A?	LIB?	VOLOUT	1	10	(2)

	___		LIB?	VOLRUN	1	10	(2)
+	___	?	?	VOLSPL	1   	10	(At least 4)
	___	?	?	VOLSPL	1   	 0	(Ditto; none shown)
	___			VOLWRK	2	10	(1 ;none shown)

	___	*FILE	LIB?	VOLOUT	1   	10	(2)
	___		LIB***	VOLRUN  1	10	(2)

		The following can only be done on UNIX.

	___	*FILE	LIB?	?	1   	10	(2)
	___			VOL***	1	10	(4)
	___			?	1	10	(7)
+	___	?	?	VOL?	1   	10	(many 20+)


+	___	03) PUTPARM & LINK TO DISPLAY   try with both D & E
		You can display the file XYZ in LIBIN on VOLIN.
		Just see that the PUTPARM & LINK works don't test 
		DISPLAY yet.

	___	04) DAY		901102  -> 6

	___	05) GETPARM 		this tests getparmbuild, displays
					a getparm only.

+	___	06) SUBMIT  (executable)    
			(VMS)	FILE=QABCKGRD  in LIBRUN    on VOLRUN
			(ACU)	FILE=QABCKGRD  in TESTACU   on SOURCE
			(MF)	FILE=QABCKGRD  in TESTMF    on SOURCE
			(LPI)	FILE=QABCKGRD  in TESTLPI   on SOURCE
				Will submit an executable on UNIX.
				Will submit a QABCKGRD.COM on VMS.
			Creates	BACK#### in LIBSPOOL on VOLSPL.
+	___		Check:  TASKTYPE=B
				TERMNUM=-1
			VMS:	PROGLIB= LIBRUN   PROGVOL= VOLRUN
			UNIX:	PROGLIB= TESTxxx  PROGVOL= SOURCE

		06) SUBMIT (script)
			(VMS)	FILE=QABCKVMS	in LIBRUN    on VOLRUN
			(ACU)	FILE=QABCKACU	in TESTACU   on SOURCE
			(MF)	FILE=QABCKMF	in TESTMF    on SOURCE
			(LPI)	FILE=QABCKLPI	in TESTLPI   on SOURCE

	___	UNIX:		This will submit qabckxxx.sh which will
				set the INVOL=BACK1 and the WORKVOL=V$$
				(this is the process #). It will then
				run QABCKGRD twice (BK1A#### and BK2A####).
				Next it wsubmits qabckxx2.sh; this sets
				INVOL=BACK2 and WORKVOL=V$$ and runs
				QABCKGRD twice (BK1B#### and BK2B####).

		The files BK1A and BK2A should have INVOL=BACK1 and have
		the same WORKLIBs and number in WORKLIB should equal WORKVOL.
		The files BK1B and BK2B should have INVOL=BACK2 and have
		the same WORKLIBs and number in WORKLIB should equal WORKVOL.
		The WORKLIBs should be different for BK1A and BK1B.

	___	VMS:		This will submit a shell/proc that will 
				in turn run QABCKGRD but will change 
				the name of the file created to 
				BGSH#### in LIBSPOOL on VOLSPL.

		See printout of BGSH#### LIBSPOOL VOLSPL and verify that the
		values are correct especially TASKTYPE = B TERMNUM = -1
		and WORKLIB should be different then current.

	___	06) SUBMIT (with parameters)
		(VMS)	FILE=QABKPVMS	in LIBRUN	on VOLRUN
		(ACU)	FILE=QABKPACU	in TESTACU	on SOURCE
		(MF)	FILE=QABKPMF	in TESTMF 	on SOURCE
		(LPI)	FILE=QABKPLPI	in TESTLPI	on SOURCE
		Press PF1 and enter 2 parmeters (the INVOL & OUTVOL)
			NEWIN
			NEWOUT
		The press RETURN, RETURN this will submit a script/proc
		that set INVOL to the first paramter and OUTVOL to the
		second parameter. It will then run QABCKGRD and create
			BCKP#### in LIBSPOOL on VOLSPL.

	___	See printout of BCKP#### LIBSPOOL VOLSPL and verify that the
		INVOL=NEWIN and OUTVOL=NEWOUT.

	___	Check your USAGE CONSTANTS to verify that they didn't get
		changed by any of these background jobs.


		07) DATE	Test each function.
				G-GREGORIAN	YYMMDD
		 PFKEY		J-JULIAN	YYDDD
	___	  <01> <HD>				(UPPERCASE)

	___	  <02> <HL>				(Lowercase)

	___	  <03> <GJ>	900101			(90001) 
	___			900000				RC=8
	___			XXX				RC=8

	___	  <04> <JG>	90001			(900101)
	___			90365			(901231)

	___	  <05> <G->	900101	900102		(1)
	___			900103	900102		(-1)

	___	  <06> <J->	90001	90002		(1)

	___	  <07> <G+>	880101	365		(881231)
			NOTE you can specify negative values in your call
			to DATE <G+> & <J+> BUT!!! this test does not
			properly sign extend into the high-order binary
			so we can't test it here.

	___	  <08> <J+>	90001	1		(90002)
	___			70001	9999		(97138)
	___			70001	10000		(97139)
			NOTE: this test using a 5 digit number in a BINARY
			data type and may not work in all cases; e.g. LPI.

	___	  <09> <GD>	901024			(WEDNESDAY)

	___	  <10> <JD>	90300			(SATURDAY)

		  <16> EXIT


		08) LINK	This will test LINK without parameters.
				(UNIX: set WISPGID=$$ if not bourne shell.)
		Link testing each LINK-TYPE

		FILE	 LIB	 VOL	 	TYPE
		=======	 ======= ======  	====
+	___	SAMPLE2  (blank) (blank) 	(blank)
		PF16 to EXIT
+	___	TRIGGER2 (blank) (blank) 	(blank)	NOT FOUND (8) (20)
+	___	TRIGGER2 LIBEXE	 VOLRUN	 	P
		PF16 to EXIT
+	___	TRIGGER3 (blank) (blank) 	S
		PF16 to EXIT

		Link to a non-COBOL program.
+	___	PRTARGS			TYPE=(blank)

		Link to a shell/proc
+	___	UNIX: PRTARGSH		TYPE=(blank)
		VMS:  PRTARGVX

		Link with Cancel-Exit
	___	SAMPLE2		        TYPE=(blank) CANCEL=C
		Now go to  05) WANG USERSUBS TEST  17) LOGOFF
		this should take you to the LINK IS COMPLETE screen 
		COMP=16   (VMS COMP=0)

		Set CANCEL=(blank)

	___	SAMPLE2  Type=(blank)
		Now in SAMPLE2 do a 3) FILE I/O, 24) CLOSE SEQUENTIAL
		this will cause an error-getparm, do a PF16 to EXIT
		you should arrive back in SAMPLE at LINK IS COMPLETE
		and COMPCODE = 16  (VMS COMPCODE=0)

		*** Next we test LINK with parameters.

		*** For VMS this tests LINK to statically linked routines
		*** as SUB1 and SUB3 are statically linked together.

	___	FILE=SUB1  TYPE=(blank)
		In SUB1 enter 	
				LINKARG1 	AAAAA
				LINKARG2	BBBBB
				LINKARG3	CCCCC
		ENTER to LINK from SUB1 to SUB3 (SUB1 sets the CANCEL FLAG)
	___	In SUB3 the LINKARGs should have arrived.
		Modify the args
				LINKARG1 	XAAAA
				LINKARG2	XBBBB
				LINKARG3	XCCCC
		ENTER to LINK from SUB3 to SAMPLE.
		PF16 to exit SAMPLE
	___	Back in SUB3 the args should be as last modified.
		ENTER to exit SUB3 back to SUB1
	___	The args should be as modified in SUB3.
		ENTER to exit SUB1 and return to SAMPLE - LINK IS COMPLETE
		RETURN & COMP CODE should be 0

		08) LINK (with lots of parameter)
+	___	FILE=XLINK    TYPE=(blank)
		You should arrive in XLINK. 
		Next link to module=XLINK1  arg count=18  L-TYPE=(blank)
		Enter values into all 18 arguments.
+	___	ENTER should take you to XLINK1
		Ensure all args arrived.
		Modify some args.
		To go back to XLINK; set Module=(blank).
+	___	ENTER should return to XLINK.
		Ensure the modifications to the args arrived.
		To go back to SAMPLE; set Module=(blank)
+	___	ENTER should return to SAMPLE.



		09) MESSAGE	This requires two windows <W1> and <W2>.

		**** NOTE ****  If you don't have 2 windows then only do
				the tests marked with 3 asterisks (***).

	___ ***	<W1>	PORT=ABCD
			PF1		create RC=0

	___ ***		PF1		create RC=4 (already created)
	___ ***		PF2		delete RC=0
	___ ***		PF2		delete RC=8 (not found)
	___ ***		PF1		create RC=0

	___ ***		MESSAGE= THIS IS THE MESSAGE
			PF3

	___	<W2>	PORT=ABCD   TYPE=W (wait)
			PF5		should get message
	___		MESSAGE= HI THERE
			PF3

	___ ***	<W1>	TYPE=W (wait)
			PF5		should get message

	___ ***		TYPE=T (timed) TIME=0500
					Move cursor off field
			PF5		wait 5 sec then RC=8

	___ ***		PORT=XBCD
			PF5		RC=16

			PORT=ABCD
	___ ***		TYPE=K (key)	Move cursor.
			PF5		Wait until key pressed. Cursor
					should jump back. RC=12

	___		TYPE=B (Both Key & Time)  TIME=2000
			PF5		should wait
	___	<W2>	MESSAGE=BYE
			PF3		<W1> should get message and
					should stop waiting.
	___		PF2		delete port
	___ ***	<W1>	PF2		RC=8


	Run SAMPLE & 05) WANG USERSUBS TESTS (QASUBS)

		11) EXTRACT	Were only going to test a few.

		keyword 1
	___	CF   	PF3 	(UNIX:SAMPLE) (VMS:QASUBS)
	___	CL	PF3	(LIBRUN)
	___	ID	PF3	(3 char uppercase userid)
	___	I8	PF3	(8 char userid)
	___	IV	PF3	(VOLIN)
	___	NA	PF3	(user long name)  (not implemented on VMS)
	___	PC	PF3	(print class)
	___	PV	PF3	(progvol)
	___	TT	PF3	(F foreground)
	___	XV	PF3	(IPLVOL constant)

		keyword 3
		In HELP screen set form number to 017 first.
	___	FN	PF6	Should be 17 (Form Number)
	___	W#	PF6	Number from wsysconfig or TTMAP.
				UNIX:	EXIT program, then look in
					wsysconfig for the returned number
					and note the device (/dev/ttyxxx)
					Run "tty" and the device should
					match

				VMS:	EXIT program, then look in TTMAP
					for the returned number and note
					the device. Do a "SHOW PROCESS"
					and look a the "terminal" field
					the device should match.

	Run SAMPLE & 05) WANG USERSUBS TESTS (QASUBS)

	___	Set USAGE CONSTANTS form number to 000.

		12) PRINT   file PRTFILE in LIBSPOOL on VOLSPL
	
		Do twice:

	___	PRINT_MODE=S DISPOSITION=DS (save)    COPY=3 CLASS=A
		Verify that three copies are printed and the file is
		not deleted.
	___	PRINT_MODE=S DISPOSITION=DX (scratch) COPY=1 CLASS=B
		Verify that one copy is printed and the file is deleted.

	___	13) LINKPROC 		This will link to a shell script 
					or DCL proc passing args. 
			VMS:	FILE=PRTARGVX  TESTVMS SOURCE
			UNIX: 	FILE=PRTARGSH  TESTxxx SOURCE
					Set up some args (remember to set 
					lengths) the first 0 length will
					terminate the list. This shell 
					script will run	the program 
					"prtargs" which will print out 
					the args and return.
			UNIX: The script does an EXIT 123 so COMPCODE=123

		14) BELL/PAUSE
	___	BELL 	PF1	1 2 5   (number of times to ring bell)
	___	PAUSE	PF2	100 500 (hunderths of seconds to pause,
					you should move your cursor out
					of the field before pressing PF2
					so you can see it pop back when
					complete.)

		15) SCRATCH
	___	F-file  PRTFILE2 in LIBSPOOL on VOLSPL  (VMS: ext=LIS)
 		(check the disk)
	___	F-file  PRTFILE2 in LIBSPOOL on VOLSPL     RC=20

	___	L-Lib		    LIBSPOOL on VOLSPL     RC=0
		(check the disk)
	___	L-Lib		    LIBSPOOL on VOLSPL     RC=16

	___	F-file  LARGE    in LIBOUT   on VOLOUT     RC=0
+	___	F-file  AFILE    in LIBOUT   on VOLOUT     RC=0


		18) PUTPARM 		Using PRNAME "INPUT" you can
					issue a putparm then run DISPLAY
					to issue the getparm.

+	___	Test simple PUTPARM, cancel, and count
		Function=D  USAGE COUNT=1  FILE=AAA
		Function=D  USAGE COUNT=1  FILE=BBB     PUTPARM_LABEL=BBB
		Function=D  USAGE COUNT=2  FILE=CCC
		Function=C  USAGE COUNT=1  FILE=(blank) PUTPARM_LABEL=BBB
		PF1-DISPLAY	(file=AAA)    PF16 to exit
		PF1-DISPLAY	(file=CCC)    PF16 to exit
		PF1-DISPLAY	(file=CCC)    PF16 to exit
		PF1-DISPLAY	(file=Blank)  PF16 to exit

	___	Do two PUTPARMS then do a cancel all.
		Function=D FILE=AAA 
		Function=D FILE=BBB 
		Function=C          PUTPARM_LABEL=(blank)
		PF1-DISPLAY	(file=Blank)  PF16 to exit

	___	Function=D  USAGE COUNT=0  FILE=ZZZ  PUTPARM_LABEL=ZZZ
		PF1-DISPLAY	(file=ZZZ  )  PF16 to exit (Do 3 times)
		Function=C PUTPARM_LABEL=ZZZ
		PF1-DISPLAY	(file=Blank)  PF16 to exit

		(Set Count=1)
		Function=E File=CCC PUTPARM_LABEL=CCC
		Function=E File=DDD PUTPARM_LABEL=DDD

	___	Function=R	    PUTPARM_LABEL=DDD
	___	Function=M	    PUTPARM_LABEL=DDD
	___	Function=M          PUTPARM_LABEL=CCC
	___	Function=R          PUTPARM_LABEL=CCC

	___	Function=E KW-CNT=0 PUTPARM_LABEL=EEE REFLABEL=CCC
	___	Function=E KW-CNT=0 PUTPARM_LABEL=FFF REFLABEL=DDD CLEANUP=C
		(Reset Cleanup=blank Reflabel=blank)
	___	Function=R KW-CNT=3 PUTPARM_LABEL=FFF		(Should DDD)
	___	Function=R KW-CNT=3 PUTPARM_LABEL=EEE		(Should CCC)
	___	Function=R KW-CNT=3 PUTPARM_LABEL=DDD		(RETCODE=4)

	___	Exit and do a 	$ wputparm -l GGG ENTER INPUT FILE=ZZZ
	___			$ wputparm -a PF2 ENTER XX3 FILE=QQQ
	___			$ wputparm show

		(go back into PUTPARM tests: run SAMPLE, PF5, PF18)

	___	Function=E File=AAA Lib=AAA Vol=AAA PP_LABEL=HHH REFLABEL=GGG

	___	Function=R	PUTPARM_LABEL=HHH   (FILE=ZZZ,LIB=AAA,VOL=AAA)

		Reset PUTPARM_LABEL=(blank)
						(Set-up for next test)
		Function=E PRNAME=XX1 FILE=GETPARM1 PF-KEY=A
		Function=D PRNAME=XX2 FILE=GETPARM2 PF-KEY=@
		PF16 to EXIT PUTPARM tests


		19) GETPARM
	___	Type="I " FORM=A PRNAME=XX1	(no display PF-KEY=A)
	___	Type="I " FORM=A PRNAME=XX2	(display FILE=GETPARM2)
	___	Type="I " FORM=A PRNAME=XX3	(no display PF-KEY=B)

	___	21) BITPACK/BITUNPK	
	___	22) HEXPACK/HEXUNPK	

		23) SEARCH
		ITEM = Can             LENGTH = 3
	___	   PF1		RC=4   Canada
	___	   PF3		RC=13  Canada
	___	   PF2		RC=0
		ITEM = United States
	___	   PF2		RC=15
	___	   PF4		RC=2

		24) SORTCALL/WISPSORT	This tests SORTCALL for VAX_CODE and
						  WISPSORT on ACU_CODE.
			input	BFILE   LIBOUT  VOLOUT
			output  BFILEX  LIBOUT  VOLOUT
			key1    1   1   C   A
			key2    2   1   C   D
			(UNIX)   filetype I

	___	Examine BFILEX; order should be 4, (5 or 6), 2, 3, 8, 7
		     	(VMS: ".DAT")

			input	BFILEX  LIBOUT  VOLOUT
			output  BFILEX2 LIBOUT  VOLOUT
			key1    5   4   C   D
			key2    1   4   C   A
			filetype F reclen 92

	___	Examine BFILEX2; order should be 3, 8, 2, 7, 6, 5, 4
		     	(VMS: ".DAT")

		WSORT utility (Do this now while fresh in your mind)
		$ wputparm clear	Clear out any stray putparms first
		$ wsort -v
			(PRNAME=INPUT)
			FILE=BFILE    LIBRARY=LIBOUT  VOLUME=VOLOUT
			FILETYPE=I   (UNIX ONLY)

			(PRNAME=KEYS)
			KEYS=2
			POST1=5   LENGTH1=4  TYPE1=C  ORDER1=D
			POST2=1   LENGTH1=4  TYPE1=C  ORDER1=A

			(PRNAME=OUTPUT)
			FILE=BFILEX3  LIBRARY=LIBOUT  VOLUME=VOLOUT

	___	Examine BFILEX3 it should be identical to BFILEX2
			$ display ( BFILEX3 LIBOUT VOLOUT )

		25) RENAME  *** VERIFY EACH STEP AGAINST THE DISK ****

			Set VOLUME=VOLOUT for all these tests.

		   PFKEY   FILE	    LIB	     N-FILE   N-LIB    RC
  		   ===	   ======== ======== ======== ======   ==
+	___	a) PF1 (F) SEQFILE1 LIBOUT   RN1      (blank)   0
	___	b) PF1 (F) SEQFILE1 LIBOUT   RN1      (blank)  20
	___	c) PF1 (F) RN1	    LIBOUT   (blank)  (blank)  56 
	___	d) PF3 (G) RN1	    LIBOUT   RN2      LIBRN     0
	___	e) PF2 (L) (blank)  LIBRN    (blank)  LIBXX     0
	___	f) PF3 (G) (blank)  LIBXX    (blank)  LIBRN     0
+	___	g) PF3 (G) AAA      LIBOUT   XFILE    LIBRN     0
	___	h) PF3 (G) BFILEX   LIBOUT   XFILE    LIBRN    52

		a) renames file SEQFILE1 to RN1 in LIBOUT (with F). 
		d) renames file RN1 in LIBOUT to RN2 in LIBRN (with G). 
		e) renames lib LIBRN to LIBXX (with L). (VMS need privs)
		f) renames lib LIBXX to LIBRN (with G). (VMS need privs)
		g) renames an indexed file (for cisam 2 part files)
		h) renames file to an existing file (should fail)


+	___	27) READVTOC
			OPTION=F    LIBRARY=LIBOUT   VOLUME=VOLOUT

	___	26) SET - Enter a keyword and a "set" value in X(20) or 9(05),
				then press the PF-KEY.  After the last one,
				verify Usage Constants from the help screen.

			Enter	Enter / Enter	Press	Should Change
			KEYWORD	X(20)	9(05)	PF-KEY	Usage Constant
			=======	=====	=====	======	==============
	___		IL	IL		PF1	INLIB
	___		IV	IV		PF1	INVOL
	___		OL	OL		PF1	OUTLIB
	___		OV	OV		PF1	OUTVOL
	___		PM	P		PF1	PRNTMODE

	___		FN		99	PF2	FORM#
	___		P#		3	PF2	PRINTER

	___	Do all of the above then go into HELP and check the USAGE
		CONSTANTS to see that they all have been set.
		(Don't bother to change them back as you're going to logoff.)

+	___	17) LOGOFF		This should really logoff.	


	___	Log back on and resetup you environment.

		UNIX: 	$ WISP=/usrxxx/wisp export WISP
			$ WISPGID=$$ export WISPGID
			$ cd $WISP/src/testxxx
			$ . startup.xxx
			$ PATH=$WISP/wisp.QA/bin:....
			$ wrun SAMPLE

		VMS: 	$ SET DEFAULT USER$DISK:[WISPQA]
			$ SCS INIT WISP SAMPLE
			$ @SRC:RESTART_QA
			$ SET DEFAULT SOURCE:[TESTVMS]
			$ RUN SAMPLE


	07) PRINTING TESTS (SAMPLE)

		1) CREATE A PRINT FILE	Creates file PRFILE LIBSPOOL VOLSPL
			Do this once for each of the following tests each
			time go to HELP and change your print constants.

		      MODE CLASS FORM
+	___		S    A    000	Should print & delete
+	___		H    A	  000	Should hold
+	___		K    A    000	Getparm - change to PRFILE2
+	___		P    B    000	Getparm - change to PRFILE3 class=Z


	???	PRINT MODE = O		Online printing

		Set MODE = P

	___	2) CREATE TEMP PRINT FILE (ADVANCING & OVERSTRIKE)
					TST####  in LIBSPOOL on VOLSPL

	___	3) CREATE A PRINT FILE WITH MULTIPLE OVERSTRIKES
					OVERSTRK in LIBSPOOL on VOLSPL

	___	5) ZERO LENGTH PRINT FILE
					ZERO#### in LIBSPOOL on VOLSPL
					Should not print a empty file.

	___	6) NO NAME PRINT FILE
					samp####   in LIBSPOOL on VOLSPL


	UTILITIES

		This section tests all of the Utilities.
		NOTE: Not all of these are available on all platforms.

	wusage

+	___	wusage version
	___	wusage help		Give usage screen.
	___	wusage shell		Enter full screen mode.
		PF16 to EXIT
	___	wusage write		Write PERSONALITY

		NOTE:   The extract syntax differs for UNIX and VMS.
			For UNIX the value is sent to stdout.
			For VMS we will put it into symbol "VALUE", you
			can then "SHOW SYMB VALUE" to see result.

	___	UNIX: wusage extract SPOOLIB
		VMS:  wusage extract &value=SPOOLIB
					Should get LIBSPOOL

	___	wusage set SPOOLIB=TSTSPOOL
	___	UNIX: wusage extract SPOOLIB
		VMS:  wusage extract &value=SPOOLIB
					Should get TSTSPOOL

	___	wusage read			Read PERSONALITY
	___	UNIX: wusage extract SPOOLIB
		VMS:  wusage extract &value=SPOOLIB
					Should get LIBSPOOL

	___	wusage flags		Set the following to "N"
						SET File Usage Constants
						Enter COMMANDS
						SAVE environment
	___	wusage shell 		The above should be missing.
	___	wusage flags set help=n
	___	run SAMPLE and try to entry HELP (^e) should beep
	___	wusage flags verify:	Help Screen			N
					SET File Usage Constants	N
					Enter COMMANDS			N
					SAVE environment		N
		Set all flags to Y

+	___	wusage shell		All options should be back

+	___	PF1 RUN		PROGRAM=SAMPLE

		PF16	- exit SAMPLE
		PF16	- exit wusage


	display

	___	display	 Should getparm  LIBIN VOLIN  (PF16 to exit)
+	___	UNIX: display .../volin/libin/xyz
		VMS:  display volin:[libin]xyz.lis
					Should go directly to display
					On VMS goes into 132 col mode.
					On UNIX stays in 80 col mode.
	___	HELP (^e)		Menu
+	___	PF3			Bottom of file
+	___	PF2			Top of file
	___	PF3  + Interrupt before done by pressing any key
	___	PF5			Next screen
	___	PF4			Prev screen

+	___	PF7			Find -enter a string the exists
	___	PF1			Home Cursor
	___	PF8			Find Next (repeat until end)
	___	PF2			Top
	___	PF7			Find -enter a non-extent string
	___	PF2			Top
	___	PF8  + Interrupt before done

	___	VMS:PF6 to 80 column mode.
	___	PF10			Scroll right (several times)
	___	PF9			Scroll left
	___	PF6			Switch to 132 & back

+	___	PF14			Print screen
	___	PF15			Print file
	___	PF16			EXIT


	wputparm
		(UNIX: you must be using /bin/sh or set WISPGID=$$)

+	___	wputparm ENTER INPUT -c 3 FILE=XYZ LIB=MYLIB VOL=VOL100
		wputparm DISPLAY OUTPUT -a PF1 FILE=ABC
		wputparm ENTER PRINT -l PRINT FILE=##FRED
		wputparm SHOW		this should show the above

+	___	wputparm CLEAR -l PRINT
		wputparm SHOW		the ENTER PRINT one should be gone

+	___	wputparm CLEAR
		wputparm SHOW		All should be gone.

+	___	wputparm ENTER SEQFIL -l SEQFIL		test backward ref

+	___	run SAMPLE 
			3) FILE I/O TEST
			6) CREATE SEQUENTIAL FILE 
				FILE=##TMP		create temp file
			EXIT from SAMPLE

+	___	wputparm SHOW			Should have KEEP
+	___	UNIX: wputparm GET FILE -l SEQFIL
+	___	VMS:  wputparm GET -l SEQFIL &symb=FILE &symb=LIBRARY

+	___	wputparm DISPLAY INPUT -l NEW -r SEQFIL
		display		- get values from reflabel SEQFIL
		wputparm show	- new putparm with same values as SEQFIL
		wputparm clear


	EDE
	___	MENUDEMO
	___	good calc
	___	good calend
	___	good clock
	___	good notepad
	___	good puzzle



	*****	VMS: Stop at this point. (Return to PORTVMS.LIS)
		The remainder of the test is UNIX only.



#####################  This page is for UNIX only  ####################

	IDSI Print Queue

+	___	ilp -h
		ilp -C Z sample.wcb		spool a file

+	___	ilpman				check if file was spooled

	___	ishut				shut down

	___	idaemon				start up

	___	ilpman				check if file now on HOLD


	WISP License

+	___	wlicense
		run SAMPLE			no "unlicensed" message


	wsubmit
	___	wsubmit QABCKGRD TESTxxx SOURCE
				file=BACK#### lib=LIBSPOOL vol=VOLSPL

	viewkey
	___	viewkey

	vcapkeys
	___	vcapkeys	Build a videocap file and test it.


	wdelwrk

	___	wdelwrk		should delete current worklib

	___	su				Remove all worklibs
		rm -r -f `cat /usr/tmp/WLIBLIST`
		rm /usr/tmp/WLIBLIST
		
	wrun
	___	wrun				should give runcbl & options
		RUNCBL=xyz export RUNCBL
	___	wrun -b -w -?			should "xyz -b -w"
		unset RUNCBL 			set RUNCBL back

	___	wrun SUB3 using AA BB CC	should start SUB3 with args

	================================================================

		TO TEST wcopy, wexists, wrename, wscratch run qautils.sh
	___	qautils.sh	(perform the following tests)

	================================================================

	wcopy
	   __	wcopy XYZ LIBIN VOLIN XXX LIBIN VOLIN	  same lib
		echo $?				should be 0
	   __	wcopy QQQ LIBIN VOLIN XXX LIBIN VOLIN	  non-extent file
		echo $?				should be 20
	   __	wcopy XYZ LIBIN VOLIN XYZ NEWLIB VOLOUT	  make a new lib
		echo $?				should be 0
	   __	wcopy library NEWLIB VOLOUT NEWLIB VOLIN  copy a lib
		echo $?				should be 0

	wexists
	   __	wexists file XYZ LIBIN VOLIN
		echo $?				should be 0  (exists)
	   __	wexists file QQQ LIBIN VOLIN
		echo $?				should be 1  (not found)
	   __	wexists library LIBIN VOLIN
		echo $?				should be 0
	   __	wexists library QQQQ VOLIN	
		echo $?				should be 1
	   __	wexists volume VOLIN	
		echo $?				should be 0
	   __	wexists volume QQQQ		
		echo $?				should be 1


	wrename
	   __	wrename XYZ NEWLIB VOLOUT NEW NEWLIB
	   __	wrename NEW NEWLIB VOLOUT NEW2 NEWLIB2
		echo $?				should be 0 (success)
	   __	wrename NEW NEWLIB VOLOUT NEW2 NEWLIB2
		echo $?				should be 20 (not found)
	   __	wrename library NEWLIB2 VOLOUT NEWLIB3

	wscratch
	   __	wscratch NEW2 NEWLIB3 VOLOUT
		echo $?				should be 0
	   __	wscratch NEW2 NEWLIB3 VOLOUT
		echo $?				should be 20
	   __	wscratch library NEWLIB3 VOLOUT
		echo $?				should be 0
	   __	wscratch library NEWLIB3 VOLOUT
		echo $?				should be 16

	================================================================

	___	ipcs				Check whats out there
		wsysinit -v			Must be SU
		ipcs				Should be cleaned-up
		ls /usr/tmp			Temp files should be gone

	___	bldmf
		checkout Makefile

	================================================================

	Return to PORTUNIX.LIS

	================================================================

????	Netron Cap

????	vsx

????	vsload

????	proctran

????	linecount

????	(ACP Routines)

????	trim


