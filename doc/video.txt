




	Glenn A. Barber and Associates, Inc.
	12229 Ventura Blvd. North Building
	Studio City, California, 91604
	(818) 980-6622


















				  VIDEO

		Video Interactive Development Environment

			       User's Guide

			    VT100/VT220 Version









	    *** DRAFT ONLY *** DRAFT ONLY *** DRAFT ONLY ***









							   By Grego Adams
							   September 1985
							   Revision  01.1


	Copyright (c) 1985 by Glenn A. Barber and Associates Inc., Studio
	City California.  All rights reserved.





				Chapter 1
			      Introduction


1.0	Overview

	VIDEO,  the Video Interactive Development Environment, is a soft-
	ware package explicitly  designed  to  support the development of
	interactive  real-time  programs  for  the  VT100/VT200 series of
	terminals. Written in the C language,   they are highly efficient
	and very portable.  Currently,  VIDEO is available for RT-11, TSX
	Plus,  the RSX family and VAX/VMS.   Additional operating systems
	can be supported by adding one small, system dependant routine.

	Because VIDEO is explicitly targeted at the VT100/VT200 terminals
	and uses significant internal optimization,   it offers both full
	functionality and  high  performance.   However,   because of its
	unique architecture,   it  does  so  without  the  overhead  (and
	inevitable error)  of  "escape sequence interpretation"  found in
	other packages.

	Above all, VIDEO is simple to use.  Although it is written in the
	C language,   it has been designed so the user need not attend to
	the idiosyncrasies and  attendant  complexities of that language.
	As such, it is suitable for use with other languages and provides
	an excellent means of rapid migration from system to system.


1.1	Basic Capabilities -  The  functions  available  from  VIDEO  are
	divided into six logically layered groups;     primitive terminal
	I/O,  terminal setup,   screen  control,   enhanced input,  forms
	management and window management. The user may call any or all of
	these levels as appropriate and mix and match them in any way. If
	only the lower levels are used then only the lower level routines
	need be included in the program. There is no unwanted overhead or
	increased program size because extra high level (unused) routines
	were needed to perform lower level functions.


1.1.1	Primitive Terminal I/O -  The primitive terminal I/O routines are
	the lowest level and provide basic  input and output suitable for
	both real-time and interactive program development.     Functions
	such as "get single character without echo" and "check if key has
	been depressed" are provided.

	The primitive terminal I/O routines are described in Chapter 3.


	-----------------------------------------------------------------
	VT100, VT200, RT-11, RSX, VAX  and  VMS are registered trademarks
	of Digital Equipment Corporation, Maynard MA.

Video Interactive Development Environment			Page 1-02
User's Guide *** DRAFT ONLY ***				     Introduction



1.1.2	Terminal Setup -   Terminal setup control allows the programer to
	alter the VT100/VT200  characteristics such as whether or not the
	keys click when depressed. Nothing is actually displayed from the
	terminal setup routines.

	The terminal setup routines are described in Chapter 4.


1.1.3	Screen Control - Screen control allows the user to select screen,
	line and character attributes,  move to specified screen locations
	and output character strings.

	The screen control routines are described in Chapter 5.


1.1.4	Enhanced Input - Enhanced  input  supports  data directed I/O and
	meta_character escape sequence processing.    Data directed input
	allows the user to get data based on data type,  rather than just
	ASCII strings.  Support is provided for integer,   floating point
	and specialized strings.

	The enhanced input routines are described in Chapter 6.


1.1.5	Forms Management - The forms management portion of VIDEO provides
	for automated form filling and single call menus.   Fields may be
	ASCII strings or data  directed  values  and  field validation is
	supported.  Forms definition and layout is done independently from
	the application program using a KED/EDT style forms editor.

	Forms management is described in Chapter 7.


1.1.6	Window Management -  Window management is the top level of VIDEO.
	It supports the calling of other programs (also written using the
	VIDEO package) in window context.  I.e. the called program uses a
	portion (or all) of the screen and then when done, the screen and
	program context are returned to the original state.   Multi-level
	windows are allowed.

	Window management is described in Chapter 8.

Video Interactive Development Environment			Page 1-03
User's Guide *** DRAFT ONLY ***			  	     Introduction



1.2	Scope of Document

	This document  is  intended  for  software  engineers  developing
	applications with VIDEO.    It assumes a knowledgeable programmer
	and is not intended as an introduction to forms or window manage-
	ment.

	The document contains 8 chapters and 3 appendicies.     Chapter 1
	(this chapter) provides introductory information. Chapter 2 gives
	an overview of the common  principles  of using the video package
	including linking instructions. Chapters 3 through 8 describe the
	specific routines associated with each functional layer.

	Appendix A contains an  outline  of  the operating techniques for
	the  end  user.   This  is  suitable  for  inclusion  with  other
	applications oriented end user documentation.

	Appendix B gives a routine index.

	Appendix C describes how to install the package.






				Chapter 2
			 Principles of Operation




2.0	Names

	All of the routines in the video library start with the letter v.
	As much as possible, the remainder of the name is similar to what
	the equivalent standard C routine would be. For example, vgetc is
	the  "video get character"  routine,   similar in action to the C
	getc "get character" routine.


2.1	Coordinate System

	In the documentation for the VT100 and VT200 series terminal, the
	screen is referenced in coordinates biased from 1.    That is the
	rows are referenced from 1 to 24 and the columns are from 1 to 80
	(or 1 to 132 in wide screen mode).    However,  the C language is
	generically 0 biased and hence,    for all screen addresses,  the
	video routines use a coordinate system of 0 to 23 and 0 to 79 (or
	0 to 131).   The origin (0,0) continues to be the upper left hand
	corner with column number  increasing  from left to right and row
	increasing in the downward direction.


2.2	Calling Conventions

	The video routines are called using standard C format. In general
	they accept only integers  and  null  terminated string arrays as
	parameters and return only integer results.  There are some noted
	exceptions such as vgetr, the get real number routine.


2.2.1	VIDEO.H Header File - A header file "video.h", defines all of the
	non-variant parameters. It is recommended that the header file be
	used rather than their numeric equivalents. For example:

		vset(BACKGROUND,LIGHT);

	is much more readable than vset(5,1);

Video Interactive Development Environment			Page 2-02
User's Guide *** DRAFT ONLY ***			  Principles of Operation



2.2.2	Return Codes -  All of the video routines use a silence is golden
	philosophy.  This means that they do not contain memory consuming
	error messages which are seldom, if ever,  used once a program is
	debugged and operational. During the debugging process though, it
	is often required  that  the  return  codes  from the routines be
	monitored for possible errors.    In general,  the video routines
	return SUCCESS (1) for success and FAILURE (0) for failure.    In
	addition,  the code OPTIMIZED (2) is returned when the action was
	performed successfully but  did  not  actually cause output to go
	to the terminal.


2.2.3	Parameter Ranges -   If a parameter is out of range (too large or
	too small),  the  parameter  is  normalized  to the closest valid
	boundary value and the operation continues.   However, FAILURE is
	returned to the caller.   For example,  an attempt to move to row
	51 using  vmove(51,0)  would  result  in  a  move to row 23 and a
	return code of FAILURE.


2.3	Optimization

	For most operations,  output is optimized.   For example,  if the
	cursor is located at coordinate (1,1) and a vmove(1,1) is issued,
	no output is actually performed  and OPTIMIZED is returned to the
	caller.


2.3.1	Optimization Bypass - In order to force output,  each routine has
	a global optimization bypass  flag  which can be set prior to the
	subroutine call.   On return from the call,   the flag will auto-
	matically be reset to allow optimization.   For example:

		extern int vopmov;	/* Reference to opt flag.     */
		vopmov = OFF;		/* Override the optimization.  */
		vmove(5,12);		/* Send this out regardless.  */
		vmove(5,12);		/* This one will be optimized */


2.3.1.1 Optimization Flag Nomenclature  -   All optimization bypass flags
	have the form vopXXX where XXX denotes the specific function. The
	optimization bypass flags are listed in Appendix C.


2.3.1.2	Optimization Flag Initial Values  -  The  initial  value  for all
	optimization  flags  is  OFF  (0).   Hence,   no  optimization is
	performed on the  first  call  to  each  of the attendant control
	routines.

Video Interactive Development Environment			Page 2-03
User's Guide *** DRAFT ONLY ***			  Principles of Operation



2.4	Global Tracking Flags

	For most operations,  optimization is achieved using global flags
	which track the current state of the screen.     Each global flag
	has the form vgfXXX where XXX is the specific item being tracked.
	To find out the current state of an item, its vgf flag can simply
	be referenced.  For example,  the flags vgfrow and vgfcol contain
	the current screen coordinates.


2.4.1	Global Flag Accuracy - It should be noted that if a program is to
	reference a global flag, the global flag may not be correct until
	it has been set by its control routine.   For example,  the video
	global flag that tracks  screen  background (vgfbkg) is preset to
	the assumed value of DARK.    This of course,  may not be correct
	until a  vset(BACKGROUND,...)  has been utilized.


2.4.2	Global Flag Initial Values -   Most global flags are preset to an
	assumed value.   For example,  the screen is assumed dark and the
	cursor position is expected to be at (0,0).    To synchronize the
	flags with the terminal the following sequence can be used at the
	beginning of a program.

		vstate(NORMAL);		/* Standard attributes */
		verase(SCREEN);		/* Erase the screen */
		vset(SCREEN,NARROW);	/* Select 80 column screen */
		vset(BACKGROUND, DARK);	/* Set background, DARK - LIGHT */
		verror("");		/* Clear error messages */
		vled(0);		/* All LEDs off (VT100 only) */
		

2.5	Mixing VIDEO I/O and C I/O

	When using the video routines,   it is possible to mix standard C
	output routines with the  video  routines,  if you do not want to
	take advantage of the optimization or use the tracking flags. All
	will work correctly  provided  the  optimization bypass flags are
	set to OFF before calling each video routine.

	In most cases however,  this  is  more  trouble  than it is worth
	since the video package has routines  equivalent to the ones in C
	and GABA recommends that the video routines be used exclusively.

	A typical problem is shown in the following example.

		vmove(0,0);		/* Move to the home position. */
		vprint("012");		/* Print 012, vgfcol now = 3. */
		printf("345");		/* vgfcol still = 3 even tho  */
					/* cursor is a column 6.      */

	Note:  Although it appears in this example that the problem could
	be overcome simply by adding the statement   vgfcol = 6;   at the
	end of the instruction  sequence,  this  in  fact would not work.
	There are other flags involved,  such as the attribute and screen
	maps, which also would not have been accurately tracked.






				Chapter 3
			 Primitive I/O Routines



3.0	Primitive Output Routines

	The primitive output routines include:

		o vprint   - video print  similar  to  C's  printf.  This
			     routine tracks the output to keep the global
			     flags up to date.

		o vputc    - video put character similar to C's putc.  It
			     uses vprint so all global tracking flags are
			     kept up to date.

		o vcontrol - video  print  similar  to  vprint  except it
			     bypasses all output tracking.  Normally, the
			     user does not call this routine directly.

	Note: when using the above routines,  output  to  the terminal is
	automatically flushed and the  programmer need not attend to this
	annoying detail.   (Autoflush  is  much more efficient and yields
	better  performance  than   reopening   the  terminal  in  single
	character (.TTYOUT) mode).

	vprint, vputc and vcontrol are described on the following pages.


3.1	Primitive Input Routines

	The primitive input routines include:

		o vgetc  - get a character from the keyboard. (Similar to
			   C's getc but no echo is performed).

		o vcheck - check if a  character  has been input from the
			   keyboard.    If no, NULL is returned, else the
			   character is returned.

		o vpushc - push a character back on the input ring buffer.

	vgetc, vcheck and vpushc are described on the following pages.

3.2	Screen Map Routines

	The screen map can used via the vmap routine.

Video Interactive Development Environment			Page 3-02
User's Guide *** DRAFT ONLY ***			   Primitive I/O Routines


Module:		vprint

Usage:		vprint(format,arg1,...);

Description:	Output a formatted string to the terminal using a syntax
		identical to the standard C printf routine.  It provides
		two functions not performed by printf.

		1. vprint will automatically flush the output ring
		   buffer after each call  thus  removing the need
		   for the programmer to think about it.

		2. vprint will perform  an  analysis of the output
		   text in order to  keep  track  of the effect on
		   the various video  global  flags such as cursor
		   position. It also maintains a map of the screen
		   screen  contents  and  keeps  a  record  of the
		   renditions of each character on the screen.

Optimizations:	If the current  character  rendition  and character set
		match those in the attribute map,   and,  if the string
		being output matches  the  screen map,  then no data is
		actually sent to the terminal.

		If data is sent to  the  terminal,  then vprint updates
		the associated screen and attribute maps.

		In performing the analysis of the output string,   only
		the basic control characters  normally used with printf
		are allowed. Namely, \n, \t, \c, \b and \f. The routine
		vcontrol must be used to output any other control char-
		acters or escape sequences.

		Note that if a \n causes a scroll,   either full screen
		or within the roll area,  the screen and attribute maps
		are shuffled appropriately.

Return values:	SUCCESS is returned if there were no errors.

		OPTIMIZED is returned if output was optimized.

		FAILURE is returned  if  there  was  an invalid control
		character in the  output  string  or  if the string too
		long for the current screen width.

Global data:	vbgscm - screen map.
		vbgatm - attribute  map  for  character  rendition and
		character set.
		vopscm - screen map optimization control flag.

Video Interactive Development Environment			Page 3-03
User's Guide *** DRAFT ONLY ***			   Primitive I/O Routines


Restrictions:	Tab expansion is assumed  to occur on 8 space boundaries.
		If the terminal is not  set  up  that way the application
		will malfunction (from the point of view of mapping).

Internal info:	When the screen map  is  updated  from the output string,
		all control  characters  are  removed  and  the string is
		inserted into the appropriate position in the map.

		An "empty" position  on  the  screen  is represented by a
		space  character  in  the  screen  map  and  a  0  in the
		attribute map.   If the  screen  is blank,   then the map
		contains nothing but spaces  and the attribute map is all
		zeros.   Note that if the character map contains a space,
		it may still display something; as in the case of reverse
		video for example.

Alternatives:	The screen map requires approximately 4K bytes of static
		memory.    For some low end applications,    this may be
		undesirable and unnecessary.     An alternate version of
		vprint is available which does  not maintain a character
		or attribute map so it is  much smaller than the regular
		version.  Note though, it still updates the other global
		tracking flags such as vgfrow and vgfcol.

		In the VIDEO library, the default vprint routine is the
		mapping version.   To  avoid  the mapping version use a
		link string which explicitly includes vnomap.obj before
		it references the video library.  For example:

			.LINK PROG,V:VNOMAP,V:VIDEO,...

Entry Points:	Since there are actually two versions of vprint, one with
		mapping and one without, the screen control routines can-
		not reference the  screen  map global variables directly.
		Otherwise,  an undefined global error would occur at link
		time.  Note however,  the higher level routines for forms
		management and window control do reference the screen map
		directly,  and hence,  the full mapping version of vprint
		is a prerequisite for them.

		The entry points for manipulating the screen map are:

		c = vgetcm(row,col); /* Get character at (row,col)      */
		a = vgetam(row,col); /* Get attribute byte at (row,col) */
		vputcm(row,col,c);   /* Put character at (row,col)      */
		vputam(row,col,c);   /* Put attribute byte at (row,col) */

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 3-04
User's Guide *** DRAFT ONLY ***			   Primitive I/O Routines


Module:		vputc

Usage:		vputc(char);

Description:	Output a single character to the terminal.

Optimizations:	As per vprint.

Return values:	As per vprint.

Global data:	As per vprint.

Restrictions:	As per vprint.

Internal info:	vputc simply creates a null terminated string out of the
		single character and then calls vprint to do the work.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 3-05
User's Guide *** DRAFT ONLY ***			   Primitive I/O Routines


Module:		vcontrol

Usage:		vcontrol(format,args...);

Description:	Outputs a control string to the terminal.     Logically,
		vcontrol is  the  equivalent  of  the  C  routine printf
		except the buffer  is  automatically  flushed after each
		call (relieving the programmer from this annoying duty).

		It varies from the video print routine, vprint,  in that
		it does not track the output or update the screen map or
		global tracking flags.    It is primarily for use within
		VIDEO itself and hence, should seldom be required by the
		applications programmer.

		However, in the circumstance where there is control data
		to be output then there is no choice but to use vcontrol
		because vprint rejects  all  but  the most basic control
		characters.   In this case,  the user must either update
		any effected global tracking flags manually,   or ensure
		that none are effected.

Example:	As an example, lets suppose you wish to send a string to
		a printer connected  locally  on a VT220 but without the
		output actually appearing on the terminal. The following
		could be used:

		vcontrol("\033[_l");          /* Printer on, term off */
		vcontrol("\fHello there\n");  /* FF and a message.    */
		vcontrol("\033[_h");          /* Printer off, term on */

		Note that vprint would  have  rejected the escape (\033)
		character in the above  and  then would have interpreted
		the remaining characters as displayable. Thus the screen
		map would have been incorrectly updated etc.

Special Note:	The idea of two routines,  vcontrol for control data and
		vprint for visible data,  is the key to the low overhead
		of VIDEO. VIDEO does not have to monitor the output text
		and perform escape  sequence  analysis to determine what
		is for control purposes and what is displayable. This is
		left up to the programmer.

		Fortunately,  the nature of the interactive programs and
		the completeness of the  VIDEO  package  seldom requires
		the use of vcontrol.  However, in the circumstance where
		it is indeed needed, the programmer must take particular
		care to understand and use it correctly.   Otherwise the
		application can malfunction.

Optimizations:	None.

Video Interactive Development Environment			Page 3-06
User's Guide *** DRAFT ONLY ***			   Primitive I/O Routines



Return values:	Always returns SUCCESS.

Global data:	None.

Restrictions:	User must update global tracking flags manually.

Internal info:	None.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 3-07
User's Guide *** DRAFT ONLY ***			   Primitive I/O Routines


Module:		vgetc

Usage:		char = vgetc();

Description:	Wait for the input of single character from the terminal
		keyboard.  Do not echo the input.

		If the input character  is  a  control  W and the global
		flag decstd  (use  standard  DEC  controls) is set.  The
		screen will be rewritten from the screen map. By default
		decstd is set to the on state. If the non-screen mapping
		version of vprint has been used, the action is a no op.

Optimizations:	None.

Return values:	Returns the character received.

Global data:	None.

Restrictions:	None.

Internal info:	vgetc is an operating system dependant assembly language
		routine.
		

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 3-08
User's Guide *** DRAFT ONLY ***			   Primitive I/O Routines


Module:		vcheck

Usage:		char c, vcheck();

		c = vcheck();

Description:	Check if a character has been entered at the keyboard. If
		a character has been entered, then the effect is the same
		as vgetc();

Optimizations:	None

Return values:	If a character has been entered, then it is returned.  If
		a character is not available then NULL (0) is returned.

Global data:	None

Restrictions:	None

Internal info:	vcheck is actually an entry point in the vgetc module.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 3-09
User's Guide *** DRAFT ONLY ***			   Primitive I/O Routines


Module:		vpushc

Usage:		char c;

		vpushc(c);

Description:	Pushes a character back onto the input ring buffer.

Optimizations:	None.
Return values:	SUCCESS (0) if the character was successfully pushed back.
		FAILURE (1) if the internal push back buffer already had a
		character in it.

Global data:	vgfpbc - last character pushed back.

Restrictions:	Only one character may be pushed back.

Internal info:	The character pushed back will be retrieved the next time
		a vgetc or a vcheck call is made.

		vpushc is actually an entry point in the vgetc module.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 3-10
User's Guide *** DRAFT ONLY ***			   Primitive I/O Routines


Module:		vmap

Usage:		#include <video.h>
		int action,row,col,nrows,ncols;
		vmap(action,row,col,nrows,ncols);

Description:	Perform  screen  oriented  operations  to  and  from  the
		character and attribute maps.  Valid actions are;

		Action		Description
		------		-----------
		CLEAR		vmap(CLEAR);  Clear the screen map but do
				not erase the screen.  Start at (row,col)
				and extend for nrows and ncols.

		REFRESH 	Refresh the  screen  from  the screen map
				starting at  (row,col)  and extending for
				nrows and ncols.

Optimizations:	None.

Return values:	SUCCESS (1) is always returned.

Global data:	None.

Restrictions:	None.

Internal info:	Before doing a REFRESH,  vmap  will  preserve  the current
		context (vstate(-1)).  The it will rewrite the screen from
		the map via  the  vcontrol  routine.   When completed, the
		original context will be restored (vstate(+1)).

		vmap directly access the screen map global arrays. If vmap
		is to be used, then the non-mapping version of vprint must
		be utilized.

Bugs / Quirks:	None known.






				Chapter 4
			 Terminal Setup Routines


4.0	Summary

	The terminal setup routines include:

		o vset   - set terminal parameters

		o vstate - select pre_defined terminal states.

		o vtab - set and clear hardware tab stops.

	The terminal setup routines  cause  the terminal hardware (and in
	some cases the operating system's terminal handler) to be config-
	ured.  However, the setup routines do not output anything that is
	actually visible to the user.

Video Interactive Development Environment			Page 4-02
User's Guide *** DRAFT ONLY ***			  Terminal Setup Routines


Module:		vset

Usage:		int item, state;
		vset(item,state);

Description:	Set  terminal  characteristic  "item"  to  state "state".
		Items and states are defined in video.h.  Valid items and
		states are:

	Item		State(s) and Description
	----		------------------------
	KEYPAD		NORMAL or APPLICATIONS

			Select normal keypad operation which generates the
			ASCII codes indicated  on  the key or applications
			mode in which the keys produce escape sequences in
			the PF series.

	CURSOR_KEYS	NORMAL or APPLICATIONS

			Select normal cursor key operation which generates
			the  standard  VT52   style  escape  sequences  or
			applications mode which generates escape sequences
			in the PF series.

	TERMINAL	VT52 or ANSI

			Put the terminal in  VT52  or  ANSI standard mode.
			Note that although  the  terminal  may be set as a
			VT52,   the video  routines  only function in ANSI
			mode.  Hence selecting VT52 mode is only useful on
			exit.

Video Interactive Development Environment			Page 4-03
User's Guide *** DRAFT ONLY ***			  Terminal Setup Routines


	WIDTH		NARROW or WIDE (80 or 132)

			Select a standard 80 column  screen or a wide 132
			column screen.     Note that as a function of the
			VT100/VT220 hardware,  the screen is cleared when
			the width is changed.

	SCROLL		JUMPY or SMOOTH

	BACKGROUND	DARK or LIGHT

	ORIGIN		SCREEN or ROLL_AREA

			Selects whether cursor positioning (via vmove) is
			relative  to  the   physical   screen  origin  or
			relative to the selected roll area.

	WRAP		ON or OFF
	AUTO_WRAP	ON or OFF

			WRAP and AUTO_WRAP are the same function.  If ON,
			output will wrap to  the  next line if an attempt
			is made to go past the right margin.  Wrap should
			be OFF for the video routines to work correctly.

	AUTO_REPEAT	ON or OFF

			Select if the keyboard keys auto-repeat or not.

	AUTO_PRINT	ON or OFF

			Selects if a printer, connected to the terminal,
			prints what is being sent to the terminal.

	REMOTE_ECHO	ON or OFF

			Selects if the terminal does it's own echo.   For
			the video routines to work correctly,   the term-
			inal should not do it's own echoing.

	NEW_LINE_MODE	ON or OFF

			Selects if the  return  key  generates a carriage
			return or a carriage return and line feed. Should
			be OFF for correct VIDEO operation.

	PRINTER		ON or OFF

			Selects if the  terminal's  printer is enabled or
			not.  If enabled,  it can accept print directives
			or operate based on the AUTO_PRINT state.

Video Interactive Development Environment			Page 4-04
User's Guide *** DRAFT ONLY ***			  Terminal Setup Routines


	INTERLACE	ON or OFF (240 or 480)

			Selects 240 or 480 interlace mode.   The default
			is 240 and for the sake of your eyes, leave it!

	PRINT_TERMINATOR NONE or FORM_FEED

			Selects whether  the  terminal's  printer should
			issue a form feed after a print screen action.

	PRINT_EXTENT	SCREEN or ROLL_AREA

			Selects whether  the  terminal's  printer should
			print the full screen or only the roll area on a
			print screen action.

	CURSOR		INVISIBLE or VISIBLE (VT200 series only)

	KEYBOARD	UNLOCKED or LOCKED (VT200 series only)

			Selects if the keyboard can transmit data.   If
			the keyboard  is  locked,   the "lock" light is
			illuminated.

	INSERT_MODE	INSERT or REPLACE (VT200 series only)


Optimizations:	Width and  background  will  not  be set if the screen is
		already at the specified value.   This may be bypassed by
		clearing the flags vopwid or vopbkg respectively.

Return values:	FAILURE (0) if state was not valid.
		SUCCESS (1) on success.
		OPTIMIZED (2) if optimization was performed.

Global data:	vgfwid - current screen width.
		vopwid - width optimization control flag.
		vgfbkg - current screen background.
		vopbkg - background optimization control flag.

Restrictions:	None.

Internal info:	None.

Bugs / Quirks:	Most  items  are   decoded  into  a  generalized  control
		sequence for which some elements are not defined.   There
		is not a check made for invalid items and no error status
		is  returned.   Use  of  invalid  items  will  result  in
		unpredictable results.

Video Interactive Development Environment			Page 4-05
User's Guide *** DRAFT ONLY ***			  Terminal Setup Routines


Module:		vstate

Usage:		int action;
		vstate(action);

Description:	If "action" is NORMAL (0),    the screen is set to a pre-
		defined "known" state.    A "known" state is one in which
		all of the terminal parameters are set to specific values
		which are  necessary  for  the  correct  operation of the
		video routines.

		Note that the NORMAL state  is  not an initialization and
		although the cursor is set  to the home position and tabs
		are forced to every  eighth  tab stop,  the screen is not
		cleared nor is a  specific  background or width selected.
		I.e.  it may be used again and again in a program without
		to  "clean up"  the terminal  without changing what is on
		the screen.

		Visual initialization  of  the  terminal  is  left to the
		programmer to do what is appropriate for the application.

		If action is  SAVE  (-1),   the  current  state   (cursor
		position and character rendition) is saved.

		If  action  is  RESTORE (+1),    the  old  state  (cursor
		position and character rendition) is restored.

Optimizations:	None.

Return values:	SUCCESS (1) if the action was completed successfully.
		FAILURE (0) if the action was invalid.

Global data:	None.

Restrictions:	Can only save to one level.    If multiple saves are done
		only the most recent is remembered.

Internal info:	None.

Bugs / Quirks:	None.

Video Interactive Development Environment			Page 4-06
User's Guide *** DRAFT ONLY ***			  Terminal Setup Routines


Module:		vtab

Usage:		int col;
		vtab(col);

Description:	Set a hardware tab stop in column col.

		If col = CLEAR then all tab stops are removed.

		If col = EIGHT_COLUMN then tab stops are set at every and
		only at every eighth column.

Optimizations:	None.

Return values:	FAILURE (0) if an invalid column was given, else SUCCESS.	

Global data:	None.

Restrictions:	None.

Internal info:	None.

Bugs / Quirks:	None known.





				Chapter 5
			 Screen Control Routines


5.0	Summary

	The screen control routines control the position,  rendition and
	size of text to be displayed.  They also manage other peripheral
	functions associated with video terminal output and provide some
	miscellaneous capabilities.

	The screen control routines include:

		o vbell  - ring the terminal bell (or buzzer).

		o vchset - select a specific character set.

		o vcrlf  - output a carriage return and line feed.

		o verase - erase all or part of the screen.

		o verror - output an error message.

		o vgrid  - output a lined grid.

		o vled   - turn VT100 led's on or off.

		o vline  - draw a line.

		o vmode  - select character attribute (bold, blink etc.)

		o vmove  - move cursor to an absolute screen position.

		o vrevlf - output a reverse line feed.

		o vroll  - set the roll area.

		o vsize  - select line size.

		o vslew  - move cursor to a relative screen position.

Video Interactive Development Environment			Page 5-02
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		vbell

Usage:		vbell();

Description:	Ring the terminal bell or buzzer.

Optimizations:	None.

Return values:	Always returns SUCCESS (1);

Global data:	None.

Restrictions:	None.

Internal info:	None.

Bugs / Quirks:	None.

Video Interactive Development Environment			Page 5-03
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		vchset

Usage:		#include <video.h>
		vchset(char_set);

Description:	Select a particular character set char_set as defined in
		video.h.  Valid character sets are:

		char_set	Description
		--------	-----------
		DEFAULT		Default (US or UK) 
		UK            	Character set for UK
		US            	Character set for US
		GRAPHICS      	Special graphics character set
		ROM_STANDARD  	Alternate character ROM std
		ROM_ALTERNATE	Alternate ROM special graphics

		The default character set is either US or UK.  The flag
		vgf_uk controls the default selection.

Optimizations:	Output will not be performed if the requested character
		set is already selected.

Return values:	SUCCESS (1) normally.
		FAILURE (0) if the char_set was not a valid code.
		OPTIMIZED (2) if the output was not performed.

Global data:	vgfchs - current character set.
		vopchs - character set optimization.
		vgf_uk - U.S. / U.K. selection flag.

Restrictions:	The U.S. / U.K.  selection  is  a screen wide rather than
		a character wide attribute due to hardware limitations in
		the VT100/VT200 terminals.   I.e. both forms of the pound
		sign cannot be  concurrently  on  the screen and changing
		the U.S. / U.K.  flag has a backwards effect on all pound
		signs on the screen.

Internal info:	Although U.S. / U.K. character set selections are options
		to vchset, they are tracked by the global flag vgf_uk not
		vgfchs and this  information  is  never transferred to the
		screen's attribute map.    This is because U.S. / U.K. is
		typically used only once at the start of a program and is
		subsequently reselected via the DEFAULT option.

Bugs / Quirks:	None known

Video Interactive Development Environment			Page 5-04
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		vcrlf

Usage:		vcrlf();

Description:	Output a carriage return and line feed.   This routine is
		the logical equivalent  of  vprint("\n") but is included
		for convenience.

Optimizations:	None.

Return values:	Always success.

Global data:	None.

Restrictions:	None.

Internal info:	None.

Bugs / Quirks:	None.

Video Interactive Development Environment			Page 5-05
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		verase

Usage:		#include <video.h>
		.
		.
		verase(control)
	
Description:	Erase all or part of the screen using:
	
		Control	  Meaning
		-------	  -------
		SCREEN	  Full screen.
		FROM_BOS  From beginning of screen to cursor.
		TO_EOS	  From cursor to end of screen.
		LINE	  Erase all of current line.
		FROM_BOL  From beginning of line to cursor.
		TO_EOL    Erase from cursor to end of line.

Optimizations:	None, an erase is always unconditional.

Return values:	SUCCESS (1) normally.
		FAILURE (0) if the control value was out of range.

Global data:	None.

Restrictions:	None.

Internal info:	Erasing all or part of a screen not only removes the data
		but also clears the character rendition.   verase makes a
		call to the internal  entry  points  vputcm and vputam in
		the vprint routine  to  update  the character map and the
		attribute map respectively.
	
Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 5-06
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		verror

Usage:		verror(format,args...);

Description:	Output an error message  to  the error line,   saving the
		screen state before  output  and restoring it afterwards.
		verror uses a syntax the same as vprint.     If the error
		text is 0, then the error line is cleared.

Optimizations:	None.

Return values:	SUCCESS (1) is always returned.

Global data:	vgferr - tracks if there is currently an error message on
			 the error line.
		errrow - specifies on  which  line  the  error text is to
			 start. By default, errrow=23 (the bottom line).
		errcol - specifies in  which  column error the text is to
			 begin. By default, errcol=0 (the left most col).

Restrictions:	The error message area  is  everything to the right of the
		errcol position.  If anything is placed on the error line
		after the error  text  it  will  be  erased the next time
		verror is called.

		Some of the predefined  menu  and form layouts assume the
		error line is in the default (bottom line) position. Care
		should be used in changing either errrow or errcol.

Internal info:	None.

Bugs / Quirks:	None know.

Video Interactive Development Environment			Page 5-07
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		vgrid

Usage:		vgrid(row,col,nrows,ncols,rdens,cdens);

Description:	This subroutine will produce a line, box or grid starting
		at position (row,col).   The width and length of the grid
		are specified by ncols and nrows  and the hashing density
		is given by rdens and cdens.

		If either the width or length is 0, then a line with hash
		marks is produced.

		If either the row density or column density is 0,  then a
		lined box (lines in one direction) is drawn.

		If both the row density and column density are 0,  then a
		rectangular box is displayed.

		If the length or width take the figure off of the screen,
		the line(s) will be clipped (as opposed to wrapped).

Optimizations:	None.

Return values:	FAILURE (0)  if  the  figure  is  clipped  or  any of the
		parameters are out of range;  SUCCESS (1) otherwise.

Global data:	None.

Restrictions:	None.

Internal info:	vgrid uses an embedded  escape  sequence  for performance
		when drawing vertical lines.   Because of this,   it uses
		vcontrol to do the output and hence,    uses the internal
		entry points vputcm  and  vputam  in vprint to update the
		screen map.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 5-08
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		vled

Usage:		vled(n);

Description:	Turn light emitting diodes (LEDs) on/off on a VT100.  If

			i = 0 = all LEDs are turned off.
			i = +1, +2, +3 or +4, turn appropriate LED on.
			i = -1, -2, -3 or -4, turn appropriate LED off.

Optimizations:	None.

Return values:	Returns FAILURE (0) if  n  is  out  of  range,  otherwise
		SUCCESS (1) is given.

Global data:	vgfled[4] - used to track the state of each led.

Restrictions:	The VT200 series does not have user LEDs.   Use of this
		routine on a VT200 is treated as a noop.

Internal info:	None.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 5-09
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		vline

Usage:		vline(type,length);

Description:	Draw a line using  the  special  graphics  character set
		starting from the current cursor position.

		If type = VERTICAL (0), a vertical line is drawn.

		If type is 1,3,5,7 or 9,  a horizontal line on that scan
		frame will be produced.

		length is the length of the line.    If the length takes
		the line off of the screen, the line is clipped.

Optimizations:	None.

Return values:	FAILURE if the  parameters  are  out  of range or if the
		line is clipped, SUCCESS otherwise.

Global data:	None.

Restrictions:	None.

Internal info:	In order to draw  vertical  lines,   an  embedded escape
		sequence is used for performance.      Hence vcontrol is
		employed rather than  vprint  and  the character map and
		attribute map are  updated  using the vprint entry point
		routines vputcm and vputam respectively.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 5-10
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		vmode
	
Usage:		#include <video.h>
		.
		.
		vmode(control);
	
Description:	Select character rendition using:

		control description
		-------	-----------
		CLEAR	Clear char rendition.
		BOLD	Select bold rendition.
		BLINK	Select blinking rendition.
		REVERSE	Select reverse video rendition.

		Values may be  ored  together  for  composite renditions.
		For example BOLD|BLINK is valid.

Optimizations:	If the current rendition matches the requested rendition,
		no output will be performed to the terminal.  This may be
		overridden by clearing the global flag vopren.

Exit status:	FAILURE (0) if the parameters were invalid, OPTIMIZED (2)
		if output was not performed and SUCCESS (1) otherwise.

Global data:	vbgren - current rendition.
		vopren - rendition optimization control flag.

Restrictions:	None.

Internal info:	None.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 5-11
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		vmove
	
Usage:		int line;
		int column;
		.
		.
		vmove(line,column);

Description:	Move to the specified line and column where:
	
		line is the integer line number  [0..23]  from the top of
		the screen  and  column  is  the  integer  column  number
		[0..131] from the left side of the screen.

Optimizations:	No output to the terminal  will  be done if the cursor is
		already at the specified location.  This optimization can
		be bypassed by clearing  the  global  flag vopmov on each
		call to vmove.

Exit status:	FAILURE (0) if either line or column were out of range.
		SUCCESS (1) on success.
		OPTIMIZED (2) if output was not performed.

Restrictions:	On an 80 column display, only [0...79] is valid.

Internal info:	None.

Global data:	vgfrow - current line number.
		vgfcol - current column.
		vopmov - vmove optimization control flag.
	
Bugs / Quirks:	None known

Video Interactive Development Environment			Page 5-12
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		vrevlf

Usage:		vrevlf();

Description:	Output a reverse line feed.    The screen will scroll down
		if the current cursor position is on the top line.

Optimizations:	None.

Return values:	vrevlf always returns SUCCESS (1).

Global data:	None.

Restrictions:	None.

Internal info:	vrevlf updates  the  global  tracking  flags  vgfrow  and
		vgfcol manually.   In  addition,   if  a  downward scroll
		occurs, either full screen or within the roll area,   the
		character and attribute  maps  will  be updated using the
		entry point routines vgetcm, vputcm, vgetam and vputam in
		vprint.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 5-13
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		vroll

Usage:		vroll(top,bottom)

Description:	Select roll area  from  top  to bottom (don't scroll full
		screen) where:

		top is the top of the scroll region [0..22] and bottom is
		the bottom of the scroll region [1..23].      Top must be
		greater than bottom.

Optimizations:	If the scroll region is already set,   no output is done.
		This may be bypassed by setting voprol = OFF.

Restrictions:	None.

Internal Info:	None.

Exit status:	OPTIMIZED (2) if no output was performed.
		FAILURE (0) if any  parameters  were  out of range or if
		bottom was greater or equal to top.
		SUCCESS (1) otherwise.

Global data:	vgfrot = current roll area top.
		vgfrob = current roll area bottom.
		voprol = bypass roll area optimization.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 5-14
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		vsize

Usage:		#include <video.h>
		.
		.
		vsize(line,size)

Description:	Set the character size  on  the specified line where line
		is the line number [0..23]. For double height characters,
		specify the bottom  line  on  which  the  change is to be
		made.   The size parameters are:

		Size		Description
		----		-----------
		SINGLE_WIDTH	single wide & single high
		DOUBLE_WIDTH	double wide, single height
		DOUBLE_HEIGHT	double high, double wide

		Note that the VT100 and  VT200  series terminals require
		double output for double high characters.     The bottom
		half of a double high  character on one line and the top
		half on the line above.

Optimizations:	No output to the terminal  will be performed if the line
		is already at the specified size.

Exit status:	FAILURE (0) if an invalid line number or size was given.
		OPTIMIZED (2) if no output was done.
		SUCCESS (1) otherwise.

Global data:	vgfsiz[24] - global line size flags.

Restrictions:	None.

Internal info:	The  parameters  DOUBLE_WIDTH  and  DOUBLE_HEIGHT  are
		designed to map into  the  vtext  control word but are
		not the same as the vgfsiz value.  The vgfsiz value is
		1 and 2 respectively.

Video Interactive Development Environment			Page 5-15
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		vslew

Usage:		vslew(nrows,ncols);

Description:	Move the cursor  by  the  specified  delta position where
		nrows is the number  of  lines  to  move and ncols is the
		number of columns.    nrows  and  ncols may be + or - the
		number of rows or columns to the edge of the screen.

Optimizations:	None.

Return values:	FAILURE (0) if nrows or ncols were out of range,  SUCCESS
		(1) otherwise.

Global data:	None.

Restrictions:	If the slew would position  the cursor off of the screen,
		it is clipped to the nearest edge.

Internal info:	vslew  updates  the  global  tracking  flags  vgfrow  and
		vgfcol.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 5-16
User's Guide *** DRAFT ONLY ***			  Screen Control Routines


Module:		vtext

Usage:		vtext(display,row,column,text);

Description:	This subroutine prints a text string at the specified co-
		ordinates with the given character rendition,   character
		set and character size.  Character attributes may be ored
		together for  composite  results.   Valid  values for the
		display parameters are  defined in video.h as outlined in
		the descriptions of the vsize, vmode and vchset routines.
		The one exception to this is the vmode(CLEAR) option.  In
		vmode, CLEAR (0) actually clears all attributes,  however
		a value of 0 to vtext means leave the rendition as it is.

		The user has the choice  as to whether or not the options
		specified remain in effect  on  return from this routine.
		If specified as positive,  the modes selected will remain
		in effect,  otherwise,  the user's state will be saved on
		entry and restored on exit.

Optimizations:	None directly.  vtext uses routines which do optimize but
		the optimization is not reported back to the caller.

Return values:	FAILURE (0) if any of  the  parameters were out of range,
		SUCCESS (1) otherwise.

Global data:	None.

Restrictions:	None.

Internal info:	None.

Bugs / Quirks:	None known.





				Chapter 6
			 Enhanced Input Routines

6.0	Summary

	The enhanced input  routines  are  divided  into two categories;
	data directed input and escape sequence resolution.

6.1	Data Directed Input

	The input of integer  and  real  numbers,    or strings which are
	filtered for valid characters is called data directed input.  The
	data directed input routines are:

		o vgets - get a filtered input string.

		o vgeti / vgetli - get a decimal integer or long value.

		o vgeto / vgetlo - get an octal integer or long value.

		o vgetx / vgetlx - get a hex integer or long value.

		o vgetf - get a single precision floating point value.

		o vgetd - get a double precision floating point value.

	In general,  all of the data directed input routines use vgets to
	input a filtered string appropriate for their data type. The then
	use the standard C routine sscanf to create the numeric result.

6.2 	Escape Sequence Resolution

	The VT100/VT200 keyboards have more keys than are provided for in
	the ASCII character set;    the extra keys generate a sequence of
	characters prefixed by an escape character '\033'.    In order to
	make it easier to process escape sequence generating keys,   they
	are decoded into single integer  values called "meta_characters".
	In addition,   the VIDEO routines also support a KED/EDT style of
	"shifted" or "gold" extensions to the meta_character set.

	The escape sequence resolution routines include:

		o vclass  - Classify a character into functional groups.

		o vescape - Continue input of an escape sequence and de-
			    code into a meta_character.

		o vgold   - Get a meta_character using keypad and cursor
			    applications mode and a KED/EDT style of key
			    input allowing for shifted (gold) keys.

		o vpushm  - Put a meta_character back on the vgold input
			    ring buffer.

Video Interactive Development Environment			Page 6-02
User's Guide *** DRAFT ONLY ***			  Extended Input Routines


Module:		vgets

Usage:		vgets(count,filter,termination,string);

Description:	Reads from the keyboard a string of length 'count'.  Only
		the characters allowed  by  the filter code 'filter' will
		be returned.    Input will be terminated according to the
		input termination routine 'termination'.

		The input protocol follows the DEC standard. For example,
		the delete key rubs out the last character,   a control U
		erases the complete input line and a control C terminates
		input,  even if some of the termination conditions  (like
		FIELD_MUST_BE_FILLED)  have  not  been  met.  This may be
		overridden by clearing the decstd global flag.

		In addition,   depressing  any  of  the four PF keys will
		also    terminates     input    provided    unless    the
		NONSTANDARD_PF_KEYS bit  has  been set in the termination
		control word.

		The valid filter values as defined in video.h are:

		filter			Description
		------			-----------

		ANY_CHARACTER		Any character is allowed.
		UPPER_CASE_ALPHABETIC   Only upper case alphabetic allowed.
		LOWER_CASE_ALPHABETIC   Only lower case alphabetic allowed.
		NUMERIC			Only numeric characters allowed.
		OCTAL			Only octal digits are allowed.
		HEXIDECIMAL		Hex digits and characters are allowed.
		Y_OR_N			Only the characters Y or N allowed.
		SPACE			Only a space character is allowed.
		LEADING_SIGN		A leading sign (+ or -) is allowed.
		SINGLE_PERIOD		A single embedded period is allowed.
		SINGLE_COLON		A single embedded colon is allowed.
		DOUBLE_COLON		Double embedded colons are allowed.
		LEADING_DOLLAR_SIGN	A leading $ sign is allowed.
		ANY_PRINTING_SYMBOL	Any printing symbol is allowed.
		CHARACTER_MASK		Any character in the char mask ok.

		Note that the above  parameters  may  be ored together to
		allow group composites.    For example,  to get an alpha-
		numeric string use:

			vgets(UPPER_CASE_ALPAHBETIC|NUMERIC);

Video Interactive Development Environment			Page 6-03
User's Guide *** DRAFT ONLY ***			  Extended Input Routines


		By default,   the return key is always a terminator.   In
		addition,    the following termination control values are
		allowed.

		Terminator		Description
		----------		-----------
		SPECIAL_TERMINATORS	Terminate on HT,VT,BS or LF.
		END_ON_FIELD_FULL	Terminate when field is full.
		RESPONSE_REQUIRED	Null response not allowed.
		FIELD_MUST_BE_FILLED	Field must be completely filled.
		PAD_WITH_SPACES		Set string to spaces on end.
		RIGHT_JUSTIFY		Right justify (leading spaces).
		NO_ECHO			Do not echo each character.
		DISPLAY_ONLY		Do not accept input here.
		NO_PRE_CLEAR		Don't clear field before entry.
		PARTIAL_KB_APPLICATIONS	Convert keypad keys to digits.
		NONSTANDARD_PF_KEYS	PF keys don't abort input.
		NO_NULL_TERMINATION	Do not null terminate the string.

Optimizations:	None.

Return Values:	NO_INPUT (0) if no input was given.
		TERM_VT  (1) if input was terminated with VT.
		TERM_LF  (2) if input was terminated with LF.
		TERM_HT  (3) if input was terminated with HT.
		TERM_BS  (4) if input was terminated with a BS.
		TERM_CR  (5) if input was terminated with a return.
		TERM_FIELD_FULL (6) if terminated on field full.

Global data:	None.

Restrictions:	None.

Internal info:	None.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 6-04
User's Guide *** DRAFT ONLY ***			  Extended Input Routines


Module(s):	vgeti, vgeto, vgetx, vgetli, vgetlo, vgetlx, vgetf, vgetd

Usage:		value = vget*(size)

Description:	Input numeric values  from  the  keyboard.   All of these
		call vgets to get a string  appropriate for decoding into
		their numeric types.    The number of characters input is
		given by the 'size' parameter.

		The routines' names are based on the standard C data type
		they are to return as per:

			vgeti	- get decimal integer
			vgeto	- get octal integer
			vgetx   - get hexadecimal integer
			vgetli  - get long decimal integer
			vgetlo  - get long octal integer
			vgetlx  - get long hex integer
			vgetf   - get single precision floating point
			vgetd   - get double precision floating point

Optimizations:	None.

Return values:	The numeric value.

Global data:	None.

Restrictions:	None.

Internal info:	None.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 6-05
User's Guide *** DRAFT ONLY ***			  Extended Input Routines


Module:		vclass

Usage:		#include <video.h>
		char c;
		int group;
		group = vclass(c);

Description:	Classify the character 'c' into a functional 'group'.

Optimizations:	None

Return values:	The values returned are:

		Group			Description
		-----			-----------
		UPPER_CASE_ALPHABETIC	Upper case alphabetic.
		LOWER_CASE_ALPHABETIC	Lower case alphabetic.
		SPACE_CHARACTER		Space character.
		NUMERIC			Numeric digit.
		ANY_PRINTING_SYMBOL	Any printable symbol.
		TERMINATOR		A CR, LF, BS or TAB.
		RUBOUT_OR_CTRL_U	Rubout or control U.
		CTRL_W_CHARACTER	Control W.
		ESCAPE_CHARACTER	Escape character.
		CTRL_C_CHARACTER	Control C.
		OTHER_CONTROL_CHARACTER	Control not explicitly recognized.
		NON_PRINTING_SYMBOL	Some non-printing character.

Global data:	None.

Restrictions:	None.

Internal info:	None.

Bugs / Quirks:	None.

Video Interactive Development Environment			Page 6-06
User's Guide *** DRAFT ONLY ***			  Extended Input Routines


Module:		vescape

Usage:		meta = vescap();

Description:	Input and classify an escape sequence.

		This subroutine is called when ever an <ESCAPE> character
		has been read by the user.

Optimizations:	None

Return values:	The value returned  will  be  according to the subsequent
		character sequence as follows:

		Meta			Description
		----			-----------
		UNKNOWN_ESCAPE_SEQUENCE Unrecognized escape sequence.

		PF1			PF1 key.
		PF2			PF2 key.
		PF3			PF3 key.
		PF4			PF4 key.

		APP_UP_ARROW		Up arrow key.
		APP_RIGHT_ARROW		Right arrow key.
		APP_DOWN_ARROW		Down arrow key.
		APP_LEFT_ARROW		Left arrow key.

		The arrow keys will only be recognized if the caller has set
		the cursor keys into applications mode with the instruction:

			vset(CURSOR_KEYS,APPLICATIONS);

		APP_ENTER		Keypad enter key.
		APP_KP_0		Keypad 0 key.
		APP_KP_1		Keypad 1 key.
		APP_KP_2		Keypad 2 key.
		APP_KP_3		Keypad 3 key.
		APP_KP_4		Keypad 4 key.
		APP_KP_5		Keypad 5 key.
		APP_KP_6		Keypad 6 key.
		APP_KP_7		Keypad 7 key.
		APP_KP_8		Keypad 8 key.
		APP_KP_9		Keypad 9 key.
		APP_KP_COMMA		Keypad comma key.
		APP_KP_MINUS		Keypad minus key.
		APP_KP_PERIOD		Keypad period key.

		The keypad keys will  only  be  recognized if the caller has
		set  the  cursor  keys  into   applications  mode  with  the
		instruction:

			vset(KEYPAD,APPLICATIONS);

Video Interactive Development Environment			Page 6-07
User's Guide *** DRAFT ONLY ***			  Extended Input Routines



Global data:	None.

Restrictions:	None.

Internal info:	In actuality, the meta_characters for the escape sequences
		are calculated by setting bit 8  (512 decimal, 1000 octal)
		in the returned value.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 6-08
User's Guide *** DRAFT ONLY ***			  Extended Input Routines


Module:		vgold

Usage:		int metachar
		metachar = vgold();

Description:	Allow shifted operations using an EDT/KED style gold key.
		The keypad is put into  applications  mode and the escape
		sequences are decoded into meta_characters as per vescape.
		If the gold key is depressed before any other key,   then
		bit 9  (the 1024 decimal, 2000 octal bit)  is  set in the
		meta_character.    The arrow keys can also be decoded but
		the caller must put  them  into  applications mode with a
		call to vset(CURSOR_KEYS,APPLICATIONS).

		In addition to the gold key operation,   a blue key (PF2)
		operation can also  be  established by setting the global
		flag v_blue.   Blue  operations  set  bit  10  (the  2048
		decimal, 4000 octal bit) in the meta_character.

Optimizations:	None.

Return values:	The meta_character input is returned.

Global data:	v_blue is used to control if blue operation is selected.

Restrictions:	None.

Internal info:	None.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 6-09
User's Guide *** DRAFT ONLY ***			  Extended Input Routines


Module:		vpushm

Usage:		int metachar;
		vpushm(metachar);

Description:	Push a meta_character  back  onto the vgold input buffer.

Optimizations:	None.

Return values:	FAILURE (0) if a  meta_character  was  already on vgold's
		push back buffer, SUCCESS (1) otherwise.

Global data:	vgfmet the meta_character push back buffer.

Restrictions:	Only one meta_character can be pushed back.

Internal info:	None.

Bugs / Quirks:	None known.



			       Chapter 7
			   Forms Management

7.0	Introduction

	For this section,  the reader is expected to be familiar with the
	concepts of  forms  management.   If  not,  then  you should read
	Appendix A before continuing.

	Appendix A also describes the  mechanics  of the data entry which
	the end user will have to perform.  However, from the programmers
	point of view,   how the data is entered is not significant.  The
	would remain the same over many different input schemes.

7.1	Form Definition

7.1.1	Forms Definition File -    A form is defined by editing a separate
	forms definition file (FDF).    The FDF contains a description of
	the fields on the form;    what their data types are and what are
	the valid value ranges.   It  also  provides  for  control of the
	form and field visual attributes as well.

	For a given applications program,  there is usually more than one
	form involved.    Therefor,  FDFs may be concatinated together to
	form a "form library".   Typically,  the form library is the same
	name as the application but with the extension .FLB  For example,
	a program called INPUT would use the forms library INPUT.FLB

7.1.2	Forms Definition File Layout - The format of an FDF is:

	FORM formname		        Keyword FORM and name of the form
	  BACKGROUND LIGHT or DARK      Background to be used
	  WIDTH NARROW or WIDE		Screen width to be used
	  BORDER WIDE or NARROW or NONE Border to be used
	  TITLE Descriptive title text	Show form title at top
	  DATE				Show date and time on form top
	  TIME				Show date and time on form top
	  MENU ABORT, HELP or EXIT	PF1 menu functions
	TEXT Message string		Textual Data
	  POSITION row,col		Position on the screen
	  SIZE SINGLE_WIDTH, DOUBLE_WIDTH or DOUBLE_HIGH
	  RENDITION BOLD, BLINK, UNDERSCORE or REVERSE
	  CHARACTER_SET US, UK, DEFAULT or GRAPHICS
	FIELD fieldname			Name of a field
	  POSITION row,col		Position on the screen
	  SIZE SINGLE_WIDTH, DOUBLE_WIDTH or DOUBLE_HIGH
	  RENDITION REVERSE or UNDERSCORE or NONE
	  DATA type			Type of data field is to contain
	  LENGTH n			Length of field in bytes
	  HELP helpful text		Help info for the field
	  VALUE n or string		Initial value
	  LIMITS lower, upper		Validation limits
	  TERMINATE ON FIELD_FULL or CR or LF etc.
	  CONTROL IS MUST_FILL or DISPLAY_ONLY etc.
	HELP Form wide helpful text	May go on for multiple lines.

Video Interactive Development Environment			Page 7-02
User's Guide *** DRAFT ONLY ***				     Form Filling


7.2	Form Filling

	The basic algorithm for filling out a form,   such as updating an
	employee record, is as follows.    It assumes the employee can be
	found by employee number or last name.

	1. Open a forms library file.

	2. Select a particular form out of the library, all fields are
	   flagged as display only  except for the last name field and
	   the employee number field.

	3. Request the form be  filled  out and return after one field
	   has been entered.

	4. Find the employee's data.

	5. Write the employee data to each of the display only fields.

	6. Modify the display only fields to allow input into them,  i.e.
	   clear the display only bit.

	7. Modify the last_name field and the employee number field to be
	   display only i.e. set the display only attribute bit.

	8. Request the form be filled out and return when the user enters
	   it (uses the <enter> key).

	9. Check which fields have changed and write them, as appropriate
	   to the employee data base.

	10. Repeat for the next employee.

7.3	Menus

	If menu input is desired,   it is very simple to generate an FDF
	which produces a selection style menu.  It is just textual lines
	with a single integer field.

	Note however,   the  routine  vmenu  provides for "pop-up" style
	menus  accessable  through  a  single  subroutine  call.    GABA
	recommends that pop-up menus be used rather than selection menus.

7.4	Independence

	For the most part,  a  form  may  be defined and changed without
	the need for a corresponding changes in the applications program
	provided a field data type  does  not change (or a string expand
	beyond the maximum length provided for it).

Video Interactive Development Environment			Page 7-03
User's Guide *** DRAFT ONLY ***				     Form Filling



7.5	Summary

	The routines used for screen management are:

		o vform  - perform form wide forms control
		o vfield - perform field specific forms control

	vform and vfield are described on the following pages.

Video Interactive Development Environment			Page 7-04
User's Guide *** DRAFT ONLY ***				 Forms Management


Module:		vform

Usage:		vform(control,string);

Description:	vform controls forms  operations  of  a form wide nature.
		The control values and associated string is a follows:

		Control	  String	Description
		-------	  ------	-----------
		OPEN	  filename	Open a forms library file.

		SELECT	  formname	Select a specific form.

		CLOSE	  filename	Terminate using the forms library.

		FILL	  form_array	Completely fill in a form.    The
					form_array must be preinitialized
					to contain  the  field  names and
					have enough  room  to contain the
					response values.

Optimizations:	None.

Return values:	FAILURE (0) if an error occurred, SUCCESS (1) otherwise.

Global data:	None.

Restrictions:	None.

Internal info:	None.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 7-05
User's Guide *** DRAFT ONLY ***				 Forms Management


Module:		vfield

Usage:		vfield(control,field_name,&data_pointer);

Description:	vfield performs operations of a field oriented nature on
		field  "field_name"  using  the data  pointed  to by the
		"data_pointer".  The control parameter options are:

		Control		Description
		-------		-----------
		GET		Get data from the specified field.

		PUT		Display data in the field.

		SET		Set a termination control bit(s), valid
				options are the same as for vgets.

		CLEAR		Clear a termination control bit(s) as
				per the description for vgets.

Optimizations:	None.

Return values:	FAILURE (0) on I/O errors, SUCCESS (1) otherwise.

Global data:	None.

Restrictions:	None.

Internal info:	None.

Bugs / Quirks:	None known.



			       Chapter 8
			   Window Management

7.0	Introduction

	The video  package  provides  an  applications  level  of window
	through three basic routines:

		o vmenu   - which provides "pop-up" menus

		o vwindow - which spawns other applications over top
			    of our window and restores our screen when
			    they exit.

	vmenu and vwindow are described on the following pages.

Video Interactive Development Environment			Page 8-02
User's Guide *** DRAFT ONLY ***				Window Management


Module:		vmenu

Usage:		char menu_array[GROUPS][ITEMS];
		int i;
		i = vmenu(menu_array);

Description:	vmenu produces a "pop-up" style menu and returns the item
		number and group it was selected from.

		Where "menu_array" is a multidimensional array containing
		the group and items.   Note that each group and item must
		be separated by exactly one space.If the number of groups
		is greater than 5,   then 132 columns are assumed and the
		array entry must be dimensioned to 132 (vice 80).

Optimizations:	None.

Return values:	The group and item numbers are returned. The group number
		is 1000 biased,  so  vmenu  would  return 3004 if the 4th
		item of the 3rd group was selected.

Global data:	None.

Restrictions:	Use of vmenu requires the mapping version of vprint.

Internal info:	None.

Bugs / Quirks:	None known.

Video Interactive Development Environment			Page 8-03
User's Guide *** DRAFT ONLY ***				Window Management


Module:		vwindow

Usage:		char file_name;
		vwindow(file_name);

Description:	vwindow spawns the program specified in file_name.  Prior
		to actually dispatching to the new program, vwindow saves
		the current screen map, global tracking flags and current
		terminal state.   When  the  spawned  program exits,  the
		screen  map,   tracking  flags  and  terminal  state  are
		restored.

Optimizations:	None.

Return values:	FAILURE (0) if the  spawned  program  exited with errors,
		otherwise SUCCESS (1) is given.

Global data:	None.

Restrictions:	None.

Internal info:	This routine is system dependant.    Under RT-11 it also
		saves the  current  system  information  as  well as the
		terminal  information  and  simulates  the  spawn  with a
		special chain exit that re-runs a cloned, context updated
		image of the application.

Bugs / Quirks:	For real-time programs  some  completion routines may be
		lost (never run even if the controlling event completed).





			       Appendix A
			      Form Filling


A.0	Introduction

	Forms management is  a  computer  technique  whereby  data may be
	obtained from a user in an  interactive manner similar to filling
	out a form on paper  except  that  the  form  is  produced on the
	screen and filled  out  using  the  keyboard  rather  than with a
	pencil.

	Of course,  computer  forms  are  much  more flexible in how they
	operate.   Not only can they collect data but they can display it
	as well, often immediately after filling out only one data item on
	the form.

	Or, more usefully,  they  can  "validate" that a piece of data is
	correct before a lot of time is  wasted entering needless infor-
	mation.  Like, why fill out a complete unemployment benefits form
	if the person made $50,000.00 the previous week.

A.1	Glossary

	On a form, a single data item is called a "field".    Checking up
	on the accuracy of a field is called "field validation".   When a
	field is filled,    the computer is notified using a "termination
	key" or just a "terminator".

A.2	Filling out a Form

A.2.1	Moving about the form - To move  about  a  form (go from field to
	field), the arrow keys are utilized.  If you are in the middle of
	one field and wish to move to the next,   you may do so using the
	arrow keys and return to the first field at a later time.    Note
	however,  that the arrow keys are not field terminators,  and any
	data entered in the field will be lost.

A.2.2	Data Entry - To enter data,  simply type what is appropriate.  In
	some cases though,  only  certain  keys  are valid.  For example,
	when entering a social security number,  only a numeric digit may
	be entered.  Any  attempt  to  enter an alphabetic character will
	result in an "invalid character" error message.

A.2.3	Field Termination - When the data for a field is completed,   the
	field is most often  terminated  with  a <tab> or a <return> key.
	<tab> will move you to the  next  horizontal field while <return>
	will move to the next vertically downward field.

	In some cases,  depending  on  the  application,   it will not be
	necessary to  enter  a  terminator;    input will terminate auto-
	matically when the field is full.

Video Interactive Development Environment			Page A-02
User's Guide *** DRAFT ONLY ***				     Form Filling



	In other cases,   an attempt to enter a terminator will yield the
	error message "field must be totally filled".     This means that
	every character position  must  be entered in the field before it
	is acceptable.  For example,  a social security number always has
	exactly nine digits.

	In still other cases,   an  attempt  to  enter  a terminator will
	result in a message  something  like  "value out of range".  This
	means that the data given  did  not  validate and must be entered
	again.

A.2.4	Form Termination -  When  the  form  is  complete,    it  may  be
	terminated using the <enter> key.    This signals the computer to
	process all of the data entered.

	In some cases, the error message "must fill field not completed".
	This means that one of the fields  on the form must be filled out
	before there is sufficient data for the computer to process.   Go
	back and complete the missing field.

A.3	Special Keys

	At the top of the keypad are for "PF" keys marked PF1,  PF2,  PF3
	and PF4.   During form filling these each have a special purpose.

A.3.1	PF1 - The PF1 key is the "menu" key.    When PF1 is depressed,  a
	single line "pop-up"  menu  will  appear  on  the top line of the
	screen.   The  menu  will  allow the selection of various options
	including:

	o abort - unconditionally abort the form (data is lost)
	o exit  - exit the form (same as <enter> key)
	o help  - give form wide / application wide helpful information.

A.3.2	PF2 - The PF2 key is the "help" key.   When PF2 is depressed,  it
	returns useful information about the field being filled out.

A.3.3	PF3 & PF4 - The PF3 and PF4  keys  are  reserved  for application
	specific functions.  If  the  application  does  not  define  the
	purpose of these keys, then they are ignored.





			       Appendix B
			     Routine Index



	Primitive I/O			Terminal Setup
	-------------			--------------
	vprint(format,args...);		vset(item,state);
	vcontrol(format,args...);	vstate(+1 | 0 | -1);
	vputc(c);			vtabs(col);
	c = vgetc();
	c = vcheck();			Screen Control
	vpushc(c);			--------------
	vmap(CLEAR | REFRESH);		vbell();
					verase(extent);
	Extended I/O			vchset(character_set);
	------------			vcrlf();
	class = vclass(c);		verror(format,args...);
	meta_char = vescape();		vgrid(row,col,nrows,ncols,rden,cden);
	vgets(string);			vled(+n | 0 | -n);
	i = vgeti();			vline(nrows,ncols);
	l = vgetli();			vmode(mode);
	f = vgetf();			vmove(row,col);
	d = vgetd();			vroll(top,bottom);
	i = vgeto();			vsize(line,size);
	l = vgetlo();			vslew(nrows,ncols);
	i = vgetx();			vrevlf();
	l = vgetlx();			vtext(control,row,col,text);
	k = vgold();
	vpushmc(k);			Window Management
					-----------------
	Forms Management		vmenu(menu_array);
	-----------------		vwindow(program_file_name);
	vform(control,string);
	vfield(control,field_name,&data_pointer);
