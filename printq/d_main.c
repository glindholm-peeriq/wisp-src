/*
 * Module:  daemon_main
 * Program: IDSIprint
 * Purpose: main code for scheduler
 *
 * $Log: d_main.c,v $
 * Revision 1.55  1992/08/04  00:17:33  jockc
 * changed fo fq and maxc to stop data bits and parity
 *
 * Revision 1.54  1992/07/14  21:35:31  jockc
 * added code to not adjust position if qpos is -1
 *
 * Revision 1.53  1992/07/10  21:18:58  jockc
 * create all dirs first.
 *
 * Revision 1.52  1992/07/10  17:27:41  jockc
 * fixed seg violation if operator not found
 *
 * Revision 1.51  1992/07/07  23:06:45  jockc
 * added improved lock for daemon detection.  fixed err message if cant
 * setuid
 *
 * Revision 1.50  1992/07/02  18:17:18  jockc
 * must allow disable of busy printer.
 *
 * Revision 1.49  1992/07/02  16:42:56  jockc
 * added init of printer_id in PITEM
 *
 * Revision 1.48  1992/06/29  21:49:56  jockc
 * *** empty log message ***
 *
 * Revision 1.47  1992/06/26  22:35:51  jockc
 * change log of errno to log of sys_errlist[errno]
 *
 * Revision 1.46  1992/06/12  20:11:32  jockc
 * added void decl for truncspc
 *
 * Revision 1.45  1992/06/09  00:05:01  jockc
 * *** empty log message ***
 *
 * Revision 1.44  1992/06/08  23:55:27  jockc
 * polish code to remove some warnings
 *
 * Revision 1.43  1992/06/04  22:38:27  jockc
 * sleep on unblocked read of unspooler pipe, to prevent tight loops
 *
 * Revision 1.42  1992/05/22  21:25:59  jockc
 * change set perms on dirs to include +x
 *
 * Revision 1.41  1992/05/20  23:14:32  jockc
 * check dumpfile versions before loading
 * changed locations of the dump files. write
 * dummy dump file for old ilpmans
 *
 * Revision 1.40  1992/05/07  22:37:23  jockc
 * NCR fix for setpgrp()
 *
 * Revision 1.39  1992/05/04  20:46:49  jockc
 * remember to clear the dump ilpconf flag
 *
 * Revision 1.38  1992/04/30  18:52:32  jockc
 * added NICEPS, ilpdef:operator list, default printer
 * pnum 0 behavior changed back, version number gen moved
 * to utils.c
 *
 * Revision 1.37  1992/04/29  21:05:31  jockc
 * fixed formfeed reversal, added filter-per-model logic
 * fixed warnings generated by GCC
 *
 * Revision 1.36  1992/03/27  22:52:52  jockc
 * validation of busy/error printers
 * prtnum 0 allowed, allow printer init to come from file
 * create dirs init and pstatus if not exist.  clear ready
 * bit when ready item is reheld.. (IP's bug)
 *
 * Revision 1.35  1992/03/13  22:29:49  jockc
 * fix printer name spec that was broke when code added to handle class
 * ' ' printing
 *
 * Revision 1.34  1992/03/13  21:29:15  jockc
 *  make VERSION avail to other modules, return if mod on unspooled
 * job, move class check to: queue, change, respool.  set flags for
 * ff and banner in qitem.  fixup print with blank class. support
 * for printer is program/device
 *
 * Revision 1.33  1992/02/13  23:35:52  jockc
 * fixed autoload on config file change, support
 * no select machines()
 *
 * Revision 1.32  1992/01/06  19:37:21  jockc
 * change delete/unlink to use real_path member of qitem
 *
 * Revision 1.31  1991/12/17  22:36:57  jockc
 * validate queue functionality, new prt num and mode accepted from client
 *
 * Revision 1.30  1991/10/12  00:57:38  jockc
 * zero fitem on dumpload
 *
 * Revision 1.29  1991/10/12  00:07:04  jockc
 * toupper on queue item change
 *
 * Revision 1.28  1991/10/11  23:08:46  jockc
 * set daemon_pid permissions properly
 *
 * Revision 1.27  1991/10/10  22:38:56  jockc
 * added code for hold when stopped
 * upcase class specs
 * enable/disable printers
 *
 * Revision 1.26  1991/10/10  16:16:25  jockc
 * init unspooling flag to false
 *
 * Revision 1.25  1991/10/08  23:34:52  jockc
 * don't let unspoolers that crash clear daemon running flag
 *
 * Revision 1.24  1991/10/08  23:26:10  jockc
 * limited support for printer model
 *
 * Revision 1.23  1991/10/07  18:25:36  jockc
 * allow hold of stopped job
 *
 * Revision 1.22  1991/10/01  17:04:49  jockc
 * add support for new prt, class, form def.
 * simplify communications.  tore out client handling
 * stuff.  added file load and dump for q and prt info
 * massive changes throughout the system
 *
 * Revision 1.21  1991/09/12  03:22:40  jockc
 * fixed hang on del printer bug
 *
 * Revision 1.20  1991/08/07  18:35:15  jockc
 * turn on fork before monitor thing again,
 * add dump queue into file, read at startup, for
 * fault tolerance
 *
 * Revision 1.19  1991/08/05  23:01:43  jockc
 * added printer number logic
 *
 * Revision 1.18  1991/08/05  19:59:13  jockc
 * roll queue_id over at 9999
 *
 * Revision 1.17  1991/08/02  23:49:40  jockc
 * fixed bogus wait on client shutdown. (CST_CLOSING added)
 * fixed held file still prints bug (remove from ready list)
 * fixed behavior of delete (added unlink)
 *
 * Revision 1.16  1991/07/22  23:00:41  jockc
 * added stuff to handle printer errors
 * fixed delete of qitems from ready queue
 *
 * Revision 1.15  1991/06/27  18:24:55  jockc
 * changes related to UNIXDOMAIN socket shtuff
 *
 * Revision 1.14  1991/05/22  17:05:12  jockc
 * changes for sco: missing decl for filetime() added,
 * TIOCNOTTY missing, ioctl removed
 *
 * Revision 1.13  1991/05/13  18:11:23  jec
 * add x perm to spool dir, so procs can search it
 *
 * Revision 1.12  1991/05/07  23:43:11  jockc
 * ifdef bsdwait for union wait decl
 *
 * Revision 1.11  1991/05/07  17:01:39  jockc
 * moved setuid root to start of prog..  when non root user started
 * daemon, isrunning fails with EPERM...
 *
 * Revision 1.10  1991/05/02  19:34:07  jockc
 * many changes here:
 * 	fork daemons before monitor and query ops
 * 	implemented scheme to wait() for said procs
 * 	disconnect from controlling tty
 * 	check validity of c_head in monitor
 * 	stop using communication lock
 *
 * Revision 1.9  1991/05/01  22:45:28  jockc
 * checks for already running daemon
 *
 * Revision 1.8  1991/04/30  23:30:24  jockc
 * misc stuff:
 * daemon correctly handles form specs in iprintcap that are
 * numeric (yacc grammar expected alpha).  No delay in wisp
 * screen manager at startup. also reentry into ilpwisp routines
 * are now ok
 *
 * Revision 1.7  1991/04/30  17:43:57  jockc
 * misc cleanup
 *
 * Revision 1.6  1991/04/25  21:24:58  jockc
 * *** empty log message ***
 *
 * Revision 1.5  1991/04/23  18:57:44  jockc
 * add pid to startup message
 *
 * Revision 1.4  1991/04/19  00:56:08  jockc
 * *** empty log message ***
 *
 * Revision 1.3  1991/04/19  00:47:17  jockc
 * *** empty log message ***
 *
 * Revision 1.2  1991/04/19  00:22:24  jockc
 * fixed version stuff
 *
 * Revision 1.1  1991/04/18  23:49:33  jockc
 * Initial revision
 *
 *
 */
static char copyright[] = "Copyright 1991 International Digital Scientific, Inc. All Rights Reserved.";
static char rcsid[] = "$Id:$";

char VERSION[5];
static char MODDATE[20];

/*#define FG*/
#define _DAEMON_MAIN_

#ifndef MQCODE
#define FORKMON
#endif

#include <fcntl.h>
#include "daemon.h"

int loadcfg();
void daemon_shutdown();
void exitbug();
int reapchild();

extern char *sys_errlist[];

main(argc,argv)
int argc;
char *argv[];
{
#ifdef BSDWAIT
	union wait waitstat;
#endif
	time_t filetime();

#if defined(NICEPS) && !defined(FG)
	if (argv[1]==NULL || strlen(argv[1])<FAKEARGLEN)
	{
		execlp(argv[0],"idaemon",FAKEARG,0);
	}
	else
	{
		progname_ptr = argv[1];
		strcpy(progname_ptr,DMAINNAME);
	}
#endif
	if (setuid(0)== -1)
	{
		fprintf(stderr,"%s: can't setuid root: %s (errno=%d)\n",argv[0],
			sys_errlist[errno],errno);
		exit(1);
	}
	
	if (isrunning())
	{
		fprintf(stderr,"IDSI scheduler already running\n");
		exit(0);
	}
#ifdef SOCKCODE
	unlink(SOCKETPATH);
#endif
	q_head=q_ptr=q_tail=ready_head=r_ptr=NULL;
	p_head=p_ptr=NULL;
	f_head=f_ptr=NULL;
	u_head=u_ptr=NULL;

	if (access(INITDIR,0)!=0)
	{
		mkdir(INITDIR,0777);
		chmod(INITDIR,0777);
	}
	if (access(PSTATUSLOGS,0)!=0)
	{
		mkdir(PSTATUSLOGS,0777);
		chmod(PSTATUSLOGS,0777);
	}
	if (access(DUMPDIR,0)!=0)
	{
		mkdir(DUMPDIR,0777);
		chmod(DUMPDIR,0777);
	}		
	make_vers_date(rcsid,VERSION,MODDATE);
	formdef_time=filetime(FORMDEF);
	loadformdef();
	classdef_time=filetime(CLASSDEF);
	loadclassdef();
	ilpdef_time=filetime(ILPDEF);
	loadqconfig();
	need_to_dump_cfg=TRUE;
	dump_conf();

	write_old_qdump_file();
		
	daemon();
	loadpcap();									/* it's changed, so reload */
	printcap_time=filetime(PRINTCAP);
	updateprtrs();									/* update what we have */
	if (!access(PDUMPFILE,0)) load_pdump(); /* check enable/disable status */
	need_to_dump_p=TRUE;
	dump_p();

	signal(SIGUSR2,daemon_shutdown);
#ifdef SYSVWAIT
	signal(SIGCLD, SIG_IGN);
#endif
#ifndef FG
	signal( SIGILL,  exitbug );
	signal( SIGEMT,  exitbug );
	signal( SIGBUS,  exitbug );
	signal( SIGSEGV, exitbug );
#endif	
	lockfile(LK_SET,DAEMON_RUNNING);
#ifdef SOCKCODE
	lockfile(LK_SET,SOCKVERSION);
#endif
#ifdef MQCODE
	lockfile(LK_SET,MQVERSION);
#endif

	/* FIXME: temp fix for 3.2 release of WISP */
	daemon_lock_set();
	
	while (1)									/* endless loop */
	{
		unspool();								/* unspool if necessary */

		if (receive_rq()>0)						/* check for RQs from clients */
		  service_rq();	
#ifdef BSDWAIT
		wait3(&waitstat,WNOHANG,(struct rusage *)0);
#endif
		reorder_q();								/* adjust the queue if necessary */
		dump_stuff();								/* write queue and prt files */
		check_unspoolers();
		check_config_files();
		validate_q(); /* scan for deleted entries */
		validate_printers(); /* check out error'd printers */
	}										/* clients */
}
service_rq()
{
	packetrq = (PACKET*)messbuf;

	if (packetrq->magic != PACKETMAGIC)
	{
		logerr("WARNING: received packet that appears to be either corrupted\n");
		logerr("or from an earlier (incompatible) version of ilp or ilpman.\n");
		return;
	}
	if (packetrq->version != PACKETVERSION)
	{
		logerr("WARNING:received packet with an incompatible version number.\n");
		logerr("Expected %d, received %d.  Verify ilp or ilpman version.\n",PACKETVERSION,packetrq->version);
		return;
	}
	switch (packetrq->functype)
	{
	      case M_CHANGE:     
		change();
		break;
		
	      case M_QUEUE:      
		queue();
		break;

	      default:
		exception(BADTYPE);
		break;
	}
}
queue()
{
	QLIST *newlist;
	char *gmem();
	PITEM *findpitem();
	FITEM *findfitem();

	newlist=(QLIST*)gmem(sizeof(QLIST));
	if (q_head==NULL)
	{
		q_head=newlist;
		q_head->prev=NULL;
		q_head->next=NULL;
		q_tail=newlist;
	}
	else
	{
		q_tail->next=newlist;
		newlist->prev = q_tail;
		newlist->next = NULL;
		q_tail = newlist;
	}

	q_tail->data = (QITEM*)gmem(sizeof(QITEM));

	memcpy(q_tail->data,&(packetrq->data),sizeof(QITEM));
	q_tail->data->q_pos = q_depth();
	q_tail->data->q_id  = ++queue_id;
	if (queue_id == 9999) queue_id=0;
	
	q_tail->data->owner_uid=packetrq->sender_uid;
	q_tail->data->owner_pid=packetrq->sender_pid;
	q_tail->data->owner_station=packetrq->sender_station;
	
	if (strlen(q_tail->data->requested_prtr))
	{
		strcpy(q_tail->data->actual_prtr,q_tail->data->requested_prtr);
		q_tail->data->printer = findpitem(q_tail->data->requested_prtr);
	}
	else
	{
		if (q_tail->data->class == 0 && q_tail->data->prtnum == 0)
		{
			strcpy(q_tail->data->requested_prtr,qconfig.default_printer);
			q_tail->data->printer = findpitem(q_tail->data->requested_prtr);
		}
	}
	if (q_tail->data->copies==0) q_tail->data->copies=1;

	q_tail->data->fitem = findfitem(q_tail->data->form);
	q_tail->data->class = q_tail->data->class?toupper(q_tail->data->class):' ';

	get_class_chars(q_tail->data);
	
	if (q_tail->data->mode & QMD_HOLD) q_tail->data->status |= QST_HOLDING;
	queue_modified();
}
removeqitem(q)
QLIST *q;
{
	QLIST *n,*p;
	removereadyqitem(q);
	for (q_ptr = q_head; q_ptr && q_ptr != q; q_ptr=q_ptr->next);
	if (q_ptr)
	{
		p=q_ptr->prev;
		n=q_ptr->next;
		if (p) p->next=n;
		if (n) n->prev=p;
		if (q_head==q_ptr) q_head=n;
		if (q_tail==q_ptr) q_tail=p;
		free(q_ptr);
	}
}
removereadyqitem(q)
QLIST *q;
{
	QLIST *n,*p;
	
	if (ISREADY(q->data))
	{
		for (r_ptr = ready_head; r_ptr && r_ptr->data->q_id != q->data->q_id; r_ptr=r_ptr->next);
		if (r_ptr)
		{
			p=r_ptr->prev;
			n=r_ptr->next;
			if (p) p->next=n;
			if (n) n->prev=p;
			if(ready_head==r_ptr) ready_head = n;
			free(r_ptr);
		}
	}
	q->data->status &= ~QST_READY;
}
queue_modified()
{
	need_to_dump=TRUE;
}
pstatus_changed()
{
	need_to_dump_p=TRUE;
}
q_depth()										/* return size of queue */
{
	int i;
	if (q_head==NULL) return 0;
	for(i=0,q_ptr=q_head; q_ptr ; ++i) NEXT(q_ptr);
	
	return i;
}

change()
{
	PITEM *p, *findpitem();
	QLIST *q, *findqitem();
	FITEM *findfitem();
	UMSG msg;
	void sigpipe();
	void truncspc();
	extern int broken_pipe;
#ifdef SIGPIPE
	signal(SIGPIPE,sigpipe);
	broken_pipe=0;
#endif			
	switch (packetrq->aux)
	{
	      case C_PRTR:
		p=findpitem(packetrq->data.p.printer_name);
		if (!p) return;
		strcpy(p->class,packetrq->data.p.class);
		strcpy(p->current_form,packetrq->data.p.current_form);
#ifdef DBGFORMTHING
		printf("1: changed form to %s\n",p->current_form);
#endif		
		truncspc(p->class);
		allcaps(p->class);
		
		truncspc(p->current_form);
		pstatus_changed();
		break;

	      case C_ENABLE:
	      case C_DISABLE:
		p = findpitem(packetrq->data.p.printer_name);
		if (!p) return;
		/*if (ISBUSY(p)) return;*/
		if (packetrq->aux==C_ENABLE)
		  p->status |= PST_ENABLED;
		else
		  p->status &= ~PST_ENABLED;
		pstatus_changed();
		break;
			       
	      case C_ALIGN:
		p=findpitem(packetrq->data.p.printer_name);
		if (!p) return;
		if (WRONGFORM(p))
		{
			msg.status = UMSG_ALIGN;
			write(p->unspooler->wfd,&msg,sizeof(UMSG));
			if (broken_pipe) { finished_unspooler(p->unspooler); break; }
		}
		else
		{
			; /* do an align the hard way */
		}
		break;
		
	      case C_FORM:
		p=findpitem(packetrq->data.p.printer_name);
		if (!p) return;
		if (!WRONGFORM(p))
		{
			if (haspriv(packetrq->sender_uid))
			    strncpy(p->current_form,packetrq->data.p.current_form,8);

		}
		else
		{
			msg.status = UMSG_FORMCHANGED;
			write(p->unspooler->wfd,&msg,sizeof(UMSG));
			if (broken_pipe) { finished_unspooler(p->unspooler); break; }
#ifndef NO_SELECT
			read(p->unspooler->rfd,&msg,sizeof(UMSG));
#else
			while (read(p->unspooler->rfd,&msg,sizeof(UMSG))<=0)
			  sleep(2);
#endif
			if (msg.status == UMSG_NEWFORM) /* should alway be the case*/
			{
				strncpy(p->current_form,msg.message,8);

				p->status &= ~PST_FORMCHANGE;
				pstatus_changed();
				for(q_ptr=q_head;q_ptr;q_ptr=q_ptr->next) 
				  if (q_ptr->data->q_id==p->qid) q_ptr->data->status &= ~QST_CHKPRT;
				queue_modified();
			}
		}
		break;
		
	      case C_QITEM:
		q=findqitem(packetrq->data.q.q_id);
		if (!q || !haspriv(packetrq->sender_uid)) return;
		if (ISUNSPOOLED(q->data)) return;
		
		strcpy(q->data->form,packetrq->data.q.form);
		q->data->fitem = findfitem(q->data->form);

		strcpy(q->data->requested_prtr,packetrq->data.q.requested_prtr);
		strcpy(q->data->actual_prtr,packetrq->data.q.requested_prtr);
		truncspc(q->data->form);
		truncspc(q->data->requested_prtr);
		q->data->mode=packetrq->data.q.mode;
		q->data->copies=packetrq->data.q.copies;
		if (q->data->class != toupper(packetrq->data.q.class))
		{
			q->data->class=toupper(packetrq->data.q.class);
			get_class_chars(q->data);
		}
		
		q->data->stpage=packetrq->data.q.stpage;
		q->data->endpage=packetrq->data.q.endpage;
		q->data->prtnum = packetrq->data.q.prtnum;
		
		if (packetrq->data.q.q_pos != -1)
		  move_item(q,packetrq->data.q.q_pos);
		queue_modified();
		
		break;
	      case C_DELETE:
	      case C_REMOVE:
		q=findqitem(packetrq->data.q.q_id);
		if (!q || !haspriv(packetrq->sender_uid)) return;
		if (ISUNSPOOLED(q->data))
		{
			msg.status = UMSG_ABORT;
			write(q->data->printer->unspooler->wfd,&msg,sizeof(UMSG));
			if (broken_pipe) { finished_unspooler(p->unspooler); break; }
			q->data->status &= ~QST_UNSPOOLED;
			/* q->data->printer->status &= ~PST_BUSY; */
			pstatus_changed();
		}
		if (packetrq->aux == C_DELETE)
		{
			/* FIXME -- check for delete perm should be handled here, not in the man_misc code */
			/*          but for now it's easier to handle it there */
			if (unlink(q->data->real_path)<0)
			{
				int save_errno=errno;
				logerr("RCVD DELETE, calling unlink(%s)\n",q->data->real_path);
				logerr("             unlink returned %d\n",save_errno);
			}
		}
		removeqitem(q);
		queue_modified();
		break;
	      case C_UNHOLD:
		q=findqitem(packetrq->data.q.q_id);
		if (!q || !haspriv(packetrq->sender_uid)) return;
		q->data->mode &= ~QMD_HOLD;
		q->data->status &= ~QST_HOLDING;
		queue_modified();
		break;
	      case C_HOLD:
		q=findqitem(packetrq->data.q.q_id);
		if (!q || !haspriv(packetrq->sender_uid)) return;
		q->data->mode |= QMD_HOLD;
		q->data->status |= QST_HOLDING;
		if (ISUNSPOOLED(q->data) && !ISQSTOPPED(q->data))
		{
			msg.status = UMSG_ABORT;
			write(q->data->printer->unspooler->wfd,&msg,sizeof(UMSG));
			if (broken_pipe) { finished_unspooler(p->unspooler); break; }
			
			q->data->status &= ~(QST_UNSPOOLED|QST_READY|QST_CHKPRT);
			/* q->data->printer->status &= ~(PST_FORMCHANGE|PST_BUSY); */
			q->data->printer = NULL;
			strcpy(q->data->actual_prtr,q->data->requested_prtr);
			pstatus_changed();
		}
		if (ISQSTOPPED(q->data))
		{
			msg.status = UMSG_HOLD;
			write(q->data->printer->unspooler->wfd,&msg,sizeof(UMSG));
			if (broken_pipe) { finished_unspooler(p->unspooler); break; }
			q->data->status &= ~(QST_UNSPOOLED|QST_READY|QST_CHKPRT|QST_STOPPED);
			q->data->printer = NULL;
			pstatus_changed();
		}
		removereadyqitem(q);
		queue_modified();
		break;
	      case C_STOPQ:
	      case C_STARTQ:
		q=findqitem(packetrq->data.q.q_id);
		if (!q || !haspriv(packetrq->sender_uid)) return;
		if (packetrq->aux == C_STOPQ)
		{
			msg.status = UMSG_STOP;
			write(q->data->printer->unspooler->wfd,&msg,sizeof(UMSG));
			if (broken_pipe) { finished_unspooler(p->unspooler); break; }
			q->data->status |= QST_STOPPED;
			if (q->data->printer) q->data->printer->status |= PST_STOPPED;
		}
		else
		{
			msg.status = UMSG_START;
			write(q->data->printer->unspooler->wfd,&msg,sizeof(UMSG));
			if (broken_pipe) { finished_unspooler(p->unspooler); break; }
			q->data->status &= ~QST_STOPPED;
			if (q->data->printer) q->data->printer->status &= ~PST_STOPPED;
		}
		queue_modified();
		pstatus_changed();
		
		break;
	      case C_CLRERR:
		p=findpitem(packetrq->data.p.printer_name);
		if (!p) return;
		else
		{
			p->status &= ~PST_ERROR;
			pstatus_changed();
		}
		break;
	}
}
haspriv(id)			/* check for privleges (for form change, queue change, etc) */
int id;
{
	return TRUE;
}
exception(type)
int type;
{
	;
}
panic_routine(file,line,msg,err)
char *file,*msg;
int line,err;
{
	static char errbuf[200];
	
	sprintf(errbuf,"%s/%d:%s[%d]",file,line,msg,err);
	write(2,errbuf,strlen(errbuf));
	
}
void exitbug(sig)
int sig;
{
	logerr("terminating on signal %d\n",sig);
	daemon_shutdown(1);
}

void daemon_shutdown(status)
int status;
{
	shut_comm();
	
	if (errlog) fclose(errlog);
	
	if (!unspooling)
		lockfile(LK_CLEAR,DAEMON_RUNNING);
	exit(status);
}
daemon()										/* put us in daemon mode */
{
	int lockfd,lockinfo;
	int pid;
	int dp;
	char tmp[100],*gmem();

#ifndef FG
	if (pid=fork())									/* fork a background process */
	{
		dp=open(DAEMONPID,O_WRONLY|O_CREAT,0666);
		chmod(DAEMONPID,0666);
		sprintf(tmp,"%d\n",pid);
		write(dp,tmp,strlen(tmp));
		close(dp);
		fprintf(stderr,"IDSI Print Queue Daemon Release V%s (c)IDSI %s %s [pid=%d]\n",VERSION,MODDATE,
#ifdef SOCKCODE
			"<BSD IPC>",
#endif
#ifdef MQCODE
			"<SYSV IPC>",
#endif
			pid);
		exit(0);
	}
# if defined(SIGTSTP) && !defined(NCR486) && !defined(NCR32)
#ifdef ULTRIX
	setpgrp(0,getpid());
#else
	setpgrp();
#endif
	if ((dp=open("/dev/tty",O_RDWR)) >=0)
	{
#if !defined(SCO) && !defined(HPUX)
		ioctl(dp,TIOCNOTTY,NULL);
#endif
		close(dp);
	}
# else
	setpgrp();
	signal(SIGHUP,SIG_IGN);
# endif

	
	close(0);									/* disconnect us from tty */
	close(1);
	close(2);
	open("/dev/null",O_RDONLY);
	open("/dev/null",O_WRONLY);
	open("/dev/null",O_WRONLY);
#else
	fprintf(stderr,"IDSI Print Queue Daemon Release V%s (c)IDSI %s %s\n",VERSION,MODDATE
#ifdef SOCKCODE
			,"<BSD IPC>"
#endif
#ifdef MQCODE
			,"<SYSV IPC>"
#endif
		);
#endif
	if (access(DEFSPOOLDIR,0))							/* make sure spooldir is there */
	{
		mkdir(DEFSPOOLDIR,0777);
		chmod(DEFSPOOLDIR,0777);
	}
	lockfd=open(LOCKFILE,O_WRONLY|O_CREAT|O_TRUNC,0666);
	lockinfo=0;
	write(lockfd,&lockinfo,sizeof(lockinfo));
	close(lockfd);
	chmod(LOCKFILE,0666);

	if (messbuf==NULL)								/* and alloc messbuf */
	{
		messbuf=gmem(PACKET_SIZE);
	}

	queue_id=0;
	unspooling=FALSE;
	
	if (!access(QDUMPFILE,0)) load_qdump();
	queue_modified(); dump_q();
}
isrunning()
{
	int dp,pid;
	char buf[6];

	dp=open(DAEMONPID,O_RDONLY);
	if (dp== -1) return FALSE;
	read(dp,buf,5);
	close(dp);
	buf[5]=(char)0;
	pid=atoi(buf);
	
	if (kill(pid,0)==0) return TRUE;
	else return FALSE;
	
}
PITEM *findpitem(name)									/* given name, return pitem for a prtr */
char *name;
{
	PITEM *ret;
	
	for ( ret=NULL, p_ptr=p_head; p_ptr; NEXT(p_ptr))
	{
		if (!strcmp(p_ptr->data->printer_name,name))
		{
			ret=p_ptr->data;
			break;
		}
	}
	return ret;
}
PITEM *findrdyprinter(class)								/* given class, return pitem for a prtr */
char class;
{
	PITEM *ret;
	char *strchr();
	
	for ( ret=NULL, p_ptr=p_head; p_ptr; NEXT(p_ptr))
	{
		if (strchr(p_ptr->data->class,class) 					/* class must match, X class matches all?*/
		    && ISIDLE(p_ptr->data) 
		    && ISENABLED(p_ptr->data)
		    && !ISERROR(p_ptr->data))
		{
			ret=p_ptr->data;
			break;
		}
	}
	return ret;
}
QITEM *findrdyqitem(class,name,num)
char class;
char *name;
int num;
{
	QLIST *ret,*n,*p;
	QITEM *retitem;
	PITEM *findpitem();

	for (r_ptr=ready_head, ret=NULL; r_ptr; r_ptr = r_ptr->next)
	{
		if (!strcmp(r_ptr->data->requested_prtr,name))  /* job's rq'd printer takes priority */
		{
			ret=r_ptr;
			ret->data->printer = findpitem(name);
			break;
		}
		if (r_ptr->data->prtnum > 0) /* then his rq'd pnum */
		{
			if (r_ptr->data->prtnum == num) { ret=r_ptr; break; }
			else
			  continue;
		}
		if (!strlen(r_ptr->data->requested_prtr))  /* none rq'd, so look at class */
		{
			if (r_ptr->data->class == class)  
			{
				ret=r_ptr; break; 
			}
		}
		
	}
	if (!ret)  /* no jobs found, so take the first job with a space class (if any) */
	{
		for (r_ptr=ready_head, ret=NULL; r_ptr; r_ptr = r_ptr->next)
		{
			if (r_ptr->data->class == ' '
			    && strlen(r_ptr->data->requested_prtr)==0
			    && r_ptr->data->prtnum == 0)  		  
			{
				ret=r_ptr; break; 
			}  
		}
	}
	if (!ret) /* still none */
	  return NULL;

	n=ret->next;
	p=ret->prev;
	if (n) n->prev = p;
	if (p) p->next = n;
	retitem=ret->data;
	if (ready_head==ret) ready_head=n;
	free(ret);
	retitem->status &= ~QST_READY;
	return retitem;
}
killplist(p)
PLIST *p;
{
	if (p->next) killplist(p->next);
	free(p);
	
}

updateprtrs()										/* update (if necessary) printer */
{											/* info using new stuff from  */
	PITEM *findpitem(),*pptr;							/* iprintcap  */
	
	for (pcapptr=printers; strlen(pcapptr->printer); ++pcapptr)
	{
		if ((pptr=findpitem(pcapptr->printer))==NULL)
		{
			addprtr(pcapptr);
			continue;
		}
		else
		{
			pptr->baud = pcapptr->baud;
			pptr->databits = pcapptr->databits;
			pptr->stopbits = pcapptr->stopbits;
			pptr->parity = pcapptr->parity;
			pptr->prtnum = pcapptr->prtnum;
			strcpy(pptr->printer_dev,pcapptr->device);
			strcpy(pptr->hostname,pcapptr->rmachine);
			strcpy(pptr->remote_prtr,pcapptr->rprinter);
			strcpy(pptr->default_form,pcapptr->form);
			strcpy(pptr->printer_model,pcapptr->model);
			if (pcapptr->sizepri) pptr->mode |= SIZEPRI;
			else pptr->mode &= ~SIZEPRI;
			if (strlen(pcapptr->type)==0) pptr->mode |= PMD_DEVICE;
			else
			{
				if (strcmp(pcapptr->type,PRT_TYPE_DEVICE)==0) pptr->mode |= PMD_DEVICE;
				else pptr->mode &= ~PMD_DEVICE;
				if (strcmp(pcapptr->type,PRT_TYPE_PROGRAM)==0) pptr->mode |= PMD_PROGRAM;
				else pptr->mode &= ~PMD_PROGRAM;
			}
		}
	}
}
addprtr(pcap)										/* add printer to active printer list */
struct ipcapstruct *pcap;
{
	char *gmem();
	PITEM *pptr;
	static int printer_id = 1;
	
	if (p_head==NULL)
	{
		p_head=(PLIST*)gmem(sizeof(PLIST));
		p_head->next=NULL;
		pptr=p_head->data=(PITEM*)gmem(sizeof(PITEM));
	}
	else
	{
		for(p_ptr=p_head; p_ptr->next; NEXT(p_ptr));
		p_ptr->next=(PLIST*)gmem(sizeof(PLIST));
		NEXT(p_ptr);
		p_ptr->next=NULL;
		pptr=p_ptr->data=(PITEM*)gmem(sizeof(PITEM));
	}
	pptr->printer_id = printer_id++;
	pptr->baud = pcap->baud;
	pptr->databits = pcap->databits;
	pptr->stopbits = pcap->stopbits;
	pptr->parity = pcap->parity;
	pptr->prtnum = pcapptr->prtnum;
	strcpy(pptr->printer_name,pcap->printer);
	strcpy(pptr->printer_dev,pcap->device);
	strcpy(pptr->hostname,pcap->rmachine);
	strcpy(pptr->remote_prtr,pcap->rprinter);
	strcpy(pptr->default_form,pcap->form);
	strcpy(pptr->current_form,pcap->form);
	strcpy(pptr->printer_model,pcapptr->model);
	strcpy(pptr->class,pcap->class);
	pptr->status = PST_ENABLED;
	if (pcap->sizepri) pptr->mode = SIZEPRI;
	if (strlen(pcap->type)==0) pptr->mode |= PMD_DEVICE;
	else
	{
		if (strcmp(pcap->type,PRT_TYPE_DEVICE)==0) pptr->mode |= PMD_DEVICE;
		else pptr->mode &= ~PMD_DEVICE;
		if (strcmp(pcap->type,PRT_TYPE_PROGRAM)==0) pptr->mode |= PMD_PROGRAM;
		else pptr->mode &= ~PMD_PROGRAM;
	}
}
reorder_q()                                                                             /* arrange queue, build ready queue */
{
	PITEM *findrdyprinter();
	
	int pos=1;

#ifdef DBGREORDER
printf("entering reorder\n");
#endif
	if(q_head==NULL) return;

	for (q_ptr=q_head;q_ptr;q_tail=q_ptr, q_ptr = q_ptr->next)
	{
#ifdef DBGREORDER
		printf("reorder: %s q_ptr=%x, next=%x\n",q_ptr->data->orig_path,q_ptr,q_ptr->next);
		printf("        job: %s %s  printer: %s\n",
		       ISHOLDING(q_ptr->data)?"Hold":"Wait",
		       ISREADY(q_ptr->data)?"Ready":"Not ready",
		       q_ptr->data->printer?(ISIDLE(q_ptr->data->printer)?"Idle":"Busy"):"No printer");
#endif
		
		if (ISUNSPOOLED(q_ptr->data)||ISHOLDING(q_ptr->data)||ISREADY(q_ptr->data)) 
		  continue;								/* item held or already ready */

		addready(q_ptr->data);
	}


	for (q_ptr=q_head; q_ptr; q_ptr=q_ptr->next) if(ISUNSPOOLED(q_ptr->data)) 
	{
		q_ptr->data->q_pos = pos++;
	}
	for (q_ptr=q_head; q_ptr; q_ptr=q_ptr->next) if(ISREADY(q_ptr->data)) 
	{
		q_ptr->data->q_pos = pos++;
	}

	for (q_ptr=q_head; q_ptr; q_ptr=q_ptr->next) if(!ISREADY(q_ptr->data) && !ISUNSPOOLED(q_ptr->data))
	{
		q_ptr->data->q_pos = pos++;
	}

	
#ifdef DBGREORDER
printf("exiting reorder\n");
#endif
}
addready(pqitem)									/* add item to ready list */
QITEM *pqitem;
{
	QLIST *newlist;
	char *gmem();
	
	newlist=(QLIST*)gmem(sizeof(QLIST));
	if (ready_head==NULL)								/*  */
	{
		ready_head=newlist;
		ready_head->next=NULL;	
		ready_head->prev=NULL;
		ready_head->data=pqitem;
	}
	else
	{
		for(r_ptr=ready_head; r_ptr->next; NEXT(r_ptr));
		r_ptr->next=newlist;
		newlist->prev = r_ptr;
		newlist->next=NULL;
		newlist->data=pqitem;
	}
	pqitem->status |= QST_READY;							/* flag it ready */
#if 0
	pqitem->printer->status |= PST_BUSY;						/* this printer is now busy */
	if (strcmp(pqitem->form,pqitem->printer->current_form))
	{
		pqitem->printer->status |= PST_FORMCHANGE;
		pqitem->status |= QST_CHKPRT;
	}
	pstatus_changed();
#endif
#if 0
printf("placed %s on ready queue\n",pqitem->orig_path);
#endif
}
QLIST *findqitem(id)
int id;
{
	for (q_ptr=q_head; q_ptr; q_ptr=q_ptr->next) 
	{
		if (q_ptr->data->q_id == id)
		{
			return q_ptr;
		}
	}
	return NULL;
}	 
FITEM *findfitem(name)
char name[];
{
	if (strlen(name)==0) return NULL;
	
	for (f_ptr=f_head; f_ptr; f_ptr=f_ptr->next) 
	{
		if (!strcmp(f_ptr->data->form_name,name))
		{
			return f_ptr->data;
		}
	}
	return NULL;
}
addfitem(data)
FITEM *data;
{
	FLIST *newlist;
	char *gmem();
	
	newlist=(FLIST*)gmem(sizeof(FLIST));
	if (f_head==NULL)
	{
		f_head=newlist;
		f_head->next=NULL;
	}
	else
	{
		for (f_ptr = f_head; f_ptr->next; f_ptr = f_ptr->next);
		f_ptr->next = newlist;
		newlist->next = NULL;
	}
	newlist->data = data;
}
updatefitem(old,new)
FITEM *old, *new;
{
	old->lpp = new->lpp;
	strcpy(old->filterstr,new->filterstr);
	memcpy(old->initdata,new->initdata,new->initlen);
	old->initlen = new->initlen;
	old->idatatype = new->idatatype;
	freeinits(old->p_init); /* free up old space for init strings */
	freefilts(old->filts); /* and per-model-filters */
	old->p_init = new->p_init;
	old->filts = new->filts;
}
new_op(qc,name)
MASTCONFIG *qc;
char *name;
{
	int nuid;
	
	if ((nuid=getnuid(name))>=0)
	  qc->operators[qc->opcount++] = nuid;
}
freeinits(p)
init_s *p;
{
	if (p==NULL) return;
	if (p->next) freeinits(p->next);
	free(p);
}
init_s *findinititem(fi,model)
FITEM *fi;
char *model;
{
	init_s *init_p;
	
	for (init_p = fi->p_init; init_p; NEXT(init_p))
	{
		if (!strcmp(init_p->model,model))
		{
			return init_p;
		}
	}
	return NULL;
}
init_s *newinititem(fi,model)
FITEM *fi;
char *model;
{
	init_s *init_p;
	char *gmem();
	
	if (!fi->p_init) 
	{
		fi->p_init = (init_s*)gmem(sizeof(init_s));
		return fi->p_init;
	}
	for (init_p = fi->p_init; init_p->next; NEXT(init_p));
	init_p->next = (init_s*)gmem(sizeof(init_s));
	return init_p->next;
}
/* yet another case of copied code that should be shared */
freefilts(f)
filt_s *f;
{
	if (f==NULL) return;
	if (f->next) freefilts(f->next);
	free(f);
}
filt_s *findfiltitem(fi,model)
FITEM *fi;
char *model;
{
	filt_s *filt_p;
	
	for (filt_p = fi->filts; filt_p; NEXT(filt_p))
	{
		if (!strcmp(filt_p->model,model))
		{
			return filt_p;
		}
	}
	return NULL;
}
filt_s *newfiltitem(fi,model)
FITEM *fi;
char *model;
{
	filt_s *filt_p;
	char *gmem();
	
	if (!fi->filts) 
	{
		fi->filts = (filt_s*)gmem(sizeof(filt_s));
		return fi->filts;
	}
	for (filt_p = fi->filts; filt_p->next; NEXT(filt_p));
	filt_p->next = (filt_s*)gmem(sizeof(filt_s));
	return filt_p->next;
}
move_item(q,pos)
QLIST *q;
int pos;
{
	QLIST *n,*p;
	int id;

	if (ISUNSPOOLED(q->data)) return;

	p=q->prev;
	n=q->next;
	if (p) p->next=n;
	if (n) n->prev=p;

	if(q_head==q) q_head=n;
	if(q_tail==q) q_tail=p;

	if (q_ptr=q_head)
	{
		if (pos <= q_ptr->data->q_pos) 
		{
			q->prev=NULL;
			q->next = q_head;
			q_head->prev = q;
			q_head = q;
			return;
		}
		while ((pos > q_ptr->data->q_pos) && q_ptr->next) q_ptr = q_ptr->next;
		if (pos <= q_ptr->data->q_pos)
		{
			p = q_ptr->prev;
			n = q_ptr;
			q->prev = p;
			q->next = n;
			p->next = q;
			n->prev = q;
		}
		else
		{
			q_ptr->next = q;
			q->prev = q_ptr;
			q->next = NULL;
		}
	}
	else
	{
		q_head = q;
		q_head->next = q_head->prev = NULL;
	}

	if (ISREADY(q->data))
	{
		q->data->status &= ~QST_READY;
		for(r_ptr=ready_head; r_ptr; r_ptr=r_ptr->next)
		{
			if (r_ptr->data == q->data)
			{
				n=r_ptr->next;
				p=r_ptr->prev;
				if (p) p->next = n;
				if (n) n->prev = p;
				if (ready_head->data == q->data) ready_head=n;
				free(r_ptr);
			}
		}
	}
	reorder_q();
}
getnuid(p)
char *p;
{
	struct passwd *pw;
	
	pw=getpwnam(p);
	endpwent();
	if (pw)
	  return pw->pw_uid;
	else 
	  return -1;
}
dump_stuff()
{
	dump_q();
	dump_p();
	dump_conf();
}
dump_q() /* dump the queue into a file */
{
	int dump;
	int magic = QDUMPMAGIC;
	int version = DUMPVERSION;
	char errbuf[200];
	
	if (need_to_dump==FALSE) return;

	lockfile(LK_SET,DUMPING);
	if ((dump=open(QDUMPFILE,O_WRONLY|O_TRUNC|O_CREAT))<0)
	{
		sprintf(errbuf,"error opening queue dump file: %s\n",sys_errlist[errno]);
		logerr(errbuf,0);
		return;
	}
	write(dump,&magic,sizeof(magic));
	write(dump,&version,sizeof(version));
	for (q_ptr=q_head; q_ptr; q_ptr = q_ptr->next)
	{
		write(dump,q_ptr->data,sizeof(QITEM));
	}
	close(dump);
	need_to_dump=FALSE;
	chmod(QDUMPFILE,0666);
	lockfile(LK_CLEAR,DUMPING);
}
write_old_qdump_file()
{
	int dump;
	OLDQITEM dummy_qitem;
	char errbuf[200];
	
	if ((dump=open(OLDQDUMPFILE,O_WRONLY|O_TRUNC|O_CREAT))<0)
	{
		sprintf(errbuf,"error opening old queue dump file: %s\n",
			sys_errlist[errno]);
		logerr(errbuf,0);
		return;
	}
	memset(&dummy_qitem,0,sizeof(dummy_qitem));
	dummy_qitem.q_pos = 1;
	strcpy(dummy_qitem.real_path,"Currently running version");
	write(dump,&dummy_qitem,sizeof(OLDQITEM));

	++dummy_qitem.q_pos;
	sprintf(dummy_qitem.real_path,"%s of the idaemon",VERSION);
	write(dump,&dummy_qitem,sizeof(OLDQITEM));
	++dummy_qitem.q_pos;
        strcpy(dummy_qitem.real_path,"program.  This version");
	write(dump,&dummy_qitem,sizeof(OLDQITEM));

	++dummy_qitem.q_pos;
	strcpy(dummy_qitem.real_path,"of ilpman is incompatible.");
	write(dump,&dummy_qitem,sizeof(OLDQITEM));

	++dummy_qitem.q_pos;
	strcpy(dummy_qitem.real_path,"Make sure you are running");
	write(dump,&dummy_qitem,sizeof(OLDQITEM));

	++dummy_qitem.q_pos;
	sprintf(dummy_qitem.real_path,"version %s of ilpman.",VERSION);
	write(dump,&dummy_qitem,sizeof(OLDQITEM));

	close(dump);
	chmod(OLDQDUMPFILE,0666);
}
dump_p() /* dump the printer list into a file */
{
	int dump;
	int magic = PDUMPMAGIC;
	int version = DUMPVERSION;
	char errbuf[200];
	
	if (need_to_dump_p==FALSE) return;

	lockfile(LK_SET,DUMPING);
	if ((dump=open(PDUMPFILE,O_WRONLY|O_TRUNC|O_CREAT))<0)
	{
		sprintf(errbuf,"error opening printer dump file: %s\n",
			sys_errlist[errno]);
		logerr(errbuf,0);
		return;
	}
	write(dump,&magic,sizeof(magic));
	write(dump,&version,sizeof(version));
	for (p_ptr=p_head; p_ptr; p_ptr = p_ptr->next)
	{
		write(dump,p_ptr->data,sizeof(PITEM));
	}
	close(dump);
	need_to_dump_p=FALSE;
	chmod(PDUMPFILE,0666);
	lockfile(LK_CLEAR,DUMPING);
}
dump_conf()
{
	int dump;
	int magic = CDUMPMAGIC;
	int version = DUMPVERSION;
	char errbuf[200];
	
	if (need_to_dump_cfg==FALSE) return;
	lockfile(LK_SET,DUMPING);
	if ((dump=open(CDUMPFILE,O_WRONLY|O_TRUNC|O_CREAT))<0)
	{
		sprintf(errbuf,"error opening ilpconfig dump file: %s\n",
			sys_errlist[errno]);
		logerr(errbuf,0);
		return;
	}
	write(dump,&magic,sizeof(magic));
	write(dump,&version,sizeof(version));
	write(dump,&qconfig,sizeof(qconfig));
	close(dump);
	need_to_dump_cfg=FALSE;
	chmod(CDUMPFILE,0666);
	lockfile(LK_CLEAR,DUMPING);
}
load_qdump()
{
	int dump;
	QITEM cur;
	QLIST *newlist;
	char *gmem();
	PITEM *findpitem();
	long magic, version;
	
	if ((dump=open(QDUMPFILE,O_RDONLY))<0)
	{
		return;
	}

	if (read(dump,&magic,sizeof(long))!=sizeof(long))
	  goto exit_qdump;
	if (magic != QDUMPMAGIC)
	  goto exit_qdump;
	  
	if (read(dump,&version,sizeof(long))!=sizeof(long))
	  goto exit_qdump;
	if (version!=DUMPVERSION)
	  goto exit_qdump;

	while (read(dump,&cur,sizeof(QITEM)))
	{
		cur.printer=NULL;
		cur.filters=NULL;
		cur.status=QST_HOLDING;
		cur.mode |= QMD_HOLD;
		cur.fitem=NULL;
		
		newlist=(QLIST*)gmem(sizeof(QLIST));

		if (q_head==NULL)
		{
			q_head=newlist;
			q_head->prev=NULL;
			q_head->next=NULL;
			q_tail=newlist;
		}
		else
		{
			q_tail->next=newlist;
			newlist->prev = q_tail;
			newlist->next = NULL;
			q_tail = newlist;
		}
	
		q_tail->data = (QITEM*)gmem(sizeof(QITEM));
		memcpy(q_tail->data,&cur,sizeof(QITEM));
		q_tail->data->q_pos = q_depth();
		if (strlen(q_tail->data->form))
		  q_tail->data->fitem = findfitem(q_tail->data->form);
		q_tail->data->q_id  = ++queue_id;
	}
	/*queue_modified();*/
	
      exit_qdump:
	
	close(dump);
}
load_pdump()
{
	int dump;
	PITEM cur, *pi, *findpitem();
	PLIST *newlist;
	char *gmem();
	long magic, version;
	
	if ((dump=open(PDUMPFILE,O_RDONLY))<0)
	{
		return;
	}
	if (read(dump,&magic,sizeof(long))!=sizeof(long))
	  goto exit_pdump;
	if (magic != PDUMPMAGIC)
	  goto exit_pdump;
	  
	if (read(dump,&version,sizeof(long))!=sizeof(long))
	  goto exit_pdump;
	if (version!=DUMPVERSION)
	  goto exit_pdump;

	while (read(dump,&cur,sizeof(PITEM)))
	{
		pi = findpitem(cur.printer_name);
		if (!pi) continue;
		if (!(cur.status & PST_ENABLED))
		  pi->status &= ~PST_ENABLED;
	}

      exit_pdump:
	close(dump);
}
check_class(class,before,after,banner)
char class;
int *before, *after, *banner;
{
	char index;
	index = class == ' '?0: toupper(class) - '@';
	*before = class_info.classlist[index].ffbefore;
	*banner = class_info.classlist[index].header;
	*after = class_info.classlist[index].ffafter;
}	
check_config_files()
{
	int tmp;
	time_t filetime();
	if ((tmp=filetime(PRINTCAP))>printcap_time)
	{
		loadpcap();							/* it's changed, so reload */
		updateprtrs();							/* update what we have */
		printcap_time=tmp;
		need_to_dump_p=TRUE;
	}
	if ((tmp=filetime(FORMDEF))>formdef_time)
	{
		loadformdef();	
		formdef_time=tmp;
	}
	if ((tmp=filetime(CLASSDEF))>classdef_time)
	{
		loadclassdef();	
		classdef_time=tmp;
	}
	if ((tmp=filetime(ILPDEF))>ilpdef_time)
	{
		loadqconfig();	
		ilpdef_time=tmp;
		need_to_dump_cfg=TRUE;
	}
}

void sigpipe()
{
	++broken_pipe;
}
allcaps(p)
char *p;
{
	while (*p)
	{
		*p = toupper(*p);
		++p;
	}
}
validate_q()
{
	QLIST *p;
	time_t tmp,time();
	
	tmp=time(&tmp);
	if (tmp-last_qvalidate < VALIDATE_GRANULARITY)
	  return;
	
	last_qvalidate=tmp;
	for (p = q_head; p; p=p->next)
	  if (validate_qitem(p->data)==FALSE)
	    removeqitem(p);
	need_to_dump=TRUE;
}
validate_qitem(qi)
QITEM *qi;
{
	if (access(qi->real_path,0)==0) return TRUE;
	else return FALSE;
}
validate_printers()
{
	PLIST *p;
	int tmp;
	time_t time();
	
	tmp=time((time_t*)&tmp);
	if (tmp-last_pvalidate < VALIDATE_GRANULARITY)
	  return;
	
	last_pvalidate=tmp;
	for (p = p_head; p; p=p->next)
	{
		if (p->data->status & PST_ERROR || p->data->status & PST_OTHER_BUSY)
		  validate_pitem(p->data);
	}
}
validate_pitem(pi)
PITEM *pi;
{
	int save_errno,tmp_fd;
	extern int open_timeout;
	extern void opento();
	
	open_timeout=0;
	signal(SIGALRM,opento);
	alarm(5);
	tmp_fd=open(pi->printer_dev,O_WRONLY|O_CREAT);
	save_errno=errno;
	alarm(0);
	if( tmp_fd != -1 && open_timeout==0)
	{
		pi->status &= ~(PST_ERROR|PST_OTHER_BUSY);
		need_to_dump_p = TRUE;
		close(tmp_fd);
	}
}
get_class_chars(qi)
QITEM *qi;
{
	int ffa, ffb, ban;
	
	check_class(qi->class,&ffb,&ffa,&ban);
	if (ffa) qi->mode |= QMD_FFAFTER;
	else     qi->mode &= ~QMD_FFAFTER;
	if (ffb) qi->mode |= QMD_FFBEFORE;
	else     qi->mode &= ~QMD_FFBEFORE;
	if (!ban) qi->mode |= QMD_NOBANNER;
	else     qi->mode &= ~QMD_NOBANNER;
}

