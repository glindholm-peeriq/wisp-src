#ifdef OLD

	replaced by VIDEOCAP

			/************************************************************************/
			/*	      VIDEO - Video Interactive Development Environment		*/
			/*			Copyright (c) 1988, 1989, 1990			*/
			/*	 An unpublished work of International Digital Scientific Inc.	*/
			/*			    All rights reserved.			*/
			/************************************************************************/

/*						Include standard header files.							*/

#include <stdio.h>
#include "video.h"									/* Include video definitions.		*/
#include "vlocal.h"									/* Include the local definitions.	*/
#include "vdata.h"									/* Include Keyboard control definitions.*/

/*						Subroutine entry point.								*/

int vterminal()
{
	char vcheck();									/* Internal check for char function.	*/
	char c, da_string[48];								/* String for primary DA.		*/
	char da1, da2;									/* Working character storage.		*/
	register int i;									/* Working register.			*/
	int recurse;									/* Retry control flag.			*/
	extern char vgetcto();								/* Reference get char timout routine.	*/

	if (tttype != UNKNOWN) return(tttype);						/* Return if we already know the term.	*/

	recurse = 0;									/* Set that it is the first time.	*/

	vdefer(RESTORE);								/* Cannot defer now.			*/

retry:	while ((c = vcheck()) != 0);							/* Flush all type ahead.		*/
	vcontrol(chterm_esc);								/* What type of terminal are you?	*/
	vcontrol(DUMP_OUTPUT);								/* Dump the output buffer.		*/

	c = vgetcto(1);									/* Get a character in response.		*/
	if (c == 0)									/* Did we time out?			*/
	{
		tttype = vcap();							/* Yes, then get the type from the o/s.	*/
		while (vcheck() != 0);							/* Flush all typeahead.			*/
		return(tttype);								/* Return the terminal type.		*/
	}

#ifdef	MSDOS
	if ((da_string[0] = c) != '\200')						/* Is first character an escape?	*/
#else	/* VMS or unix */
	if ((da_string[0] = c) != '\033')						/* Is first character an escape?	*/
#endif	/* VMS or unix */
	{
		recurse = recurse + 1;							/* No, then count the times.		*/
		if (recurse < 100) goto retry;						/* Try for the next character.		*/
	}

	recurse = 0;
	for (i = 1; (i < 48) && ((da_string[i] = vgetcto(1)) != 'c') && da_string[i] != 0; i++);	/* Primary DA responce.	*/

	da1 = da_string[3];								/* Remember DA determanant number 1.	*/
	da2 = da_string[4];								/* Remember DA determanant number 1.	*/

	i = 0;										/* Assume unknown terminal type.	*/
	if ((da1 == '1')) i = VT100;							/* A VT100 series terminal?		*/
	if ((da1 == '6') && (da2 == 'c')) i = VT100;					/* A VT100 series terminal (VT102)?	*/
	if ((da1 == '6') && (da2 == '2')) i = VT200;					/* A VT200 series terminal?		*/
	if ((da1 == '6') && (da2 == '3')) i = VT300;					/* A VT300 series terminal?		*/
	if ((da1 == '7') && (da2 == ';')) i = ATT605;					/* An AT&T 605 terminal?		*/

	vis_space = REVERSE|UNDERSCORE|BLINK;						/* Assume blinking spaces are visible.	*/
	if ((i == VT100) || (i == VT200)) vis_space = REVERSE|UNDERSCORE;		/* Visible spaces use only rev & under.	*/
	else if (i == ATT605) vis_space = REVERSE|UNDERSCORE;
	else if (i == PRO350_RT) vis_space = REVERSE|UNDERSCORE;
	else if (i == VT300) vis_space = REVERSE|UNDERSCORE|BLINK;			/* Blinking spaces are visible.		*/
	else										/* Unknown type so try again.		*/
	{
		recurse++;								/* Count this recursion.		*/
		if (recurse <= 10) goto retry;						/* Don't do more than 10 times.		*/
	}
	return(i);									/* No, then assume it is a VT100.	*/
}

/* 				Get terminal type from the operating system.							*/

int gttfos()
{
#ifdef NOT_YET

/* This area interfaces output from VIDEO to miscellaneous (non-ANSI) terminals. It is supported only via a VIDEOCAP file.	*/
/* only ANSI terminals (VT100, VT200 and VT300 terminals are supported).	*/
/* Under unix, the terminfo file is read and the video control parameters are loaded as indicated in the following sections.	*/
/* Note, if the terminal is not in the terminfo file then, UNSUPPORTED_TERMINAL should be returned to the caller. If the	*/
/* terminal is in the terminfo file and can be loaded into video's control data base, then GENERIC_UNIX_TERMINAL should be	*/
/* send back.															*/

	strcpy(rvrsidx_esc, );								/* Reverse lf (backwards scroll).	M */
	strcpy(snglwide_esc, );								/* Set line to single width.		M */
	strcpy(dblwide_esc, );								/* Set line to double width.		M */
	strcpy(dbltop_esc, );								/* Set line to double high (top half).	  */
	strcpy(dblbot_esc, );								/* Set line to double high (bottom).	  */
	strcpy(efuls_esc, );								/* Erase full screen.			M */
	strcpy(efbos_esc, );								/* Erase from top of screen to cursor.  M */
	strcpy(eteos_esc, );								/* Erase to end of screen from cursor.	M */
	strcpy(ecurl_esc, );								/* Erase all of current line.		  */
	strcpy(efbol_esc, );								/* Erase from start of line to cursor.	M */
	strcpy(eteol_esc, );								/* Erase from cursor to end of line.	M */
	strcpy(mdclr_esc, );								/* Clear all renditions.		M */
	strcpy(mdbld_esc, );								/* Select bold rendition.		M */
	strcpy(mdundr_esc, );								/* Select underscore rendition.		M */
	strcpy(mdblk_esc, );								/* Select blinking rendition.		M */
	strcpy(mdrvrs_esc, );								/* Select reverse (negative) rendition.	M */
	strcpy(swide_esc, );								/* Select wide (132 column) screen.	M */
	strcpy(snarw_esc, );								/* Select narrow (80 column) screen.	M */
	strcpy(slight_esc, );								/* Select light (reverse) screen.	  */
	strcpy(sdark_esc, );								/* Select dark screen.			M */
	strcpy(scrarea_esc, );		/* Takes 2 line numbers as parameters.	*/	/* Select scroll area (split screen).	M */
	strcpy(mvrowcol_esc, );		/* Takes row and column as parameters.	*/	/* Move cursor to row and column.	M */
	strcpy(mvleft_esc, );		/* Takes a column distance as param.	*/	/* Scroll cursor columns to the left.	M */
	strcpy(mvright_esc, );		/* Takes a column distance as param.	*/	/* Scroll cursor columns to the right.	M */
	strcpy(mvup_esc, );								/* Move up one line.			M */
	strcpy(mvupup_esc, );		/* Takes a line distance as a param.	*/	/* Scroll cursor lines up.		M */
	strcpy(mvdown_esc, );		/* Takes a line distance as a param.	*/	/* Scroll cursor lines down.		M */
	strcpy(defchs_esc, );								/* Select default character set.	M */
	strcpy(grchs_esc, );								/* Select graphics character set.	M */
	strcpy(romstdchs_esc,"");							/* Select rom chars (not used).		  */
	strcpy(romgrchs_esc,"");							/* Select rom graphics (not used).	  */
	strcpy(dlldchs_esc, );								/* Load character set (not used).	  */
	strcpy(uschs_esc, );								/* Select US character set.		  */
	strcpy(ukchs_esc, );								/* Select UK character set.		  */
	strcpy(vt2207bit_esc,"");	/* This can be used as a general initialize string, typically to force VT200/VT300 mode.  */
	strcpy(termansi_esc,"");							/* Put in ANSI mode (not needed).	  */
	strcpy(kpapmd_esc,"");								/* Put keypad in application mode.	  */
	strcpy(kpnorm_esc,"");								/* Put keypad in normal mode.		  */
	strcpy(scrlsmooth_esc, );							/* Select smooth scroll.		M */
	strcpy(scrljump_esc, );								/* Select jump scroll.			M */
	strcpy(origscrl_esc,"");							/* Origin is scroll area (not used).	  */
	strcpy(origtos_esc,"");								/* Origin is top of screen (not used).	  */
	strcpy(arapon_esc,"");								/* Turn auto wrap on.			  */
	strcpy(arapoff_esc,"");								/* Turn auto wrap off.			  */
	strcpy(arepton_esc,"");								/* Turn auto repeat on.			  */
	strcpy(areptoff_esc,"");							/* Turn auto repeat off.		  */
	strcpy(ilaceon_esc,"");								/* Turn interlace on (not used).	  */
	strcpy(ilaceoff_esc,"");							/* Turn interlace off (not used).	  */
	strcpy(nlmdon_esc,"");								/* Line feed = new line (do not use).	  */
	strcpy(nlmdoff_esc,"");								/* Line feed = line feed (use this).	  */
	strcpy(keylckon_esc,"");							/* Turn key click on.			  */
	strcpy(keylckoff_esc,"");							/* Turn key click off.			  */
	strcpy(insmdon_esc,"");								/* Turn insert mode on (not used).	  */
	strcpy(insmdoff_esc,"");							/* Turn insert mode off (not used).	  */
	strcpy(ptermff_esc,"");								/* Print screen when ff seen (not used).  */
	strcpy(ptermnone_esc,"");							/* No print terminator (not used).	  */
	strcpy(pextscrl_esc,"");							/* Print extent = scroll area (not used). */
	strcpy(pextfull_esc,"");							/* Print extend = full screen (not used). */
	strcpy(aprnton_esc,"");								/* Auto print mode on (not used).	  */
	strcpy(aprntoff_esc,"");							/* Auto print mode off (not used).	  */
	strcpy(prnton_esc,"");								/* Printer mode on (not used).		  */
	strcpy(prntoff_esc,"");								/* Printer mode off (not used).		  */
	strcpy(cursron_esc, );								/* Make cursor visible.			M */
	strcpy(cursroff_esc, );								/* Make cursor invisible.		M */

	strcpy(vk_sequence[0][0],"");							/* Load GENERIC_BLUE_KEY sequence.	*/
	strcpy(vk_sequence[1][0],"");							/* Load GENERIC_GOLD_KEY sequence.	*/
	strcpy(vk_sequence[2][0],"");							/* Load GENERIC_PINK_KEY sequence.	*/
	strcpy(vk_sequence[3][0],"");							/* Load GENERIC_GREY_KEY sequence.	*/
	strcpy(vk_sequence[4][0],"");							/* Load GENERIC_UP_ARROW_KEY sequence.	*/
	strcpy(vk_sequence[5][0],"");							/* Load GENERIC_DOWN_ARROW_KEY seqnce.	*/
	strcpy(vk_sequence[6][0],"");							/* Load GENERIC_RIGHT_ARROW_KEY seqnce.	*/
	strcpy(vk_sequence[7][0],"");							/* Load GENERIC_LEFT_ARROW_KEY seqnce.	*/
	strcpy(vk_sequence[8][0],"");							/* Load GENERIC_HOME_KEY sequence.	*/
	strcpy(vk_sequence[9][0],"");							/* Load GENERIC_TAB_KEY sequence.	*/
	strcpy(vk_sequence[10][0],"");							/* Load GENERIC_BACKTAB_KEY sequence.	*/
	strcpy(vk_sequence[11][0],"");							/* Load GENERIC_LAST_SCREEN_KEY seqnce.	*/
	strcpy(vk_sequence[12][0],"");							/* Load GENERIC_NEXT_SCREEN_KEY seqnce.	*/
	strcpy(vk_sequence[13][0],"");							/* Load GENERIC_DELETE_KEY sequence.	*/
	strcpy(vk_sequence[14][0],"");							/* Load GENERIC_INSERT_KEY sequence.	*/
	strcpy(vk_sequence[15][0],"");							/* Load GENERIC_REMOVE_KEY sequence.	*/
	strcpy(vk_sequence[16][0],"");							/* Load GENERIC_CLEAR_FIELD_KEY seqnce.	*/
	strcpy(vk_sequence[17][0],"");							/* Load GENERIC_CLEAR_AFTER_KEY seqnce.	*/
	strcpy(vk_sequence[18][0],"");							/* Load GENERIC_CLEAR_BEFORE_KEY seq.	*/
	strcpy(vk_sequence[19][0],"");							/* Load GENERIC_CANCEL_KEY sequence.	*/
	strcpy(vk_sequence[20][0],"");							/* Load GENERIC_ENTER_KEY sequence.	*/
	strcpy(vk_sequence[21][0],"");							/* Load GENERIC_RETURN_KEY sequence.	*/
	strcpy(vk_sequence[22][0],"");							/* Load GENERIC_HELP_KEY sequence.	*/
	strcpy(vk_sequence[23][0],"");							/* Load GENERIC_FN1_KEY	sequence.	*/
	strcpy(vk_sequence[24][0],"");							/* Load GENERIC_FN2_KEY sequence.	*/
	strcpy(vk_sequence[25][0],"");							/* Load GENERIC_FN3_KEY sequence.	*/
	strcpy(vk_sequence[26][0],"");							/* Load GENERIC_FN4_KEY sequence.	*/
	strcpy(vk_sequence[27][0],"");							/* Load GENERIC_FN5_KEY sequence.	*/
	strcpy(vk_sequence[28][0],"");							/* Load GENERIC_FN6_KEY sequence.	*/
	strcpy(vk_sequence[29][0],"");							/* Load GENERIC_FN7_KEY sequence.	*/
	strcpy(vk_sequence[30][0],"");							/* Load GENERIC_FN8_KEY sequence.	*/
	strcpy(vk_sequence[31][0],"");							/* Load GENERIC_FN9_KEY sequence.	*/
	strcpy(vk_sequence[32][0],"");							/* Load GENERIC_FN10_KEY sequence.	*/
	strcpy(vk_sequence[33][0],"");							/* Load GENERIC_FN11_KEY sequence.	*/
	strcpy(vk_sequence[34][0],"");							/* Load GENERIC_FN12_KEY sequence.	*/
	strcpy(vk_sequence[35][0],"");							/* Load GENERIC_FN13_KEY sequence.	*/
	strcpy(vk_sequence[36][0],"");							/* Load GENERIC_FN14_KEY sequence.	*/
	strcpy(vk_sequence[37][0],"");							/* Load GENERIC_FN15_KEY sequence.	*/
	strcpy(vk_sequence[38][0],"");							/* Load GENERIC_FN16_KEY sequence.	*/
	strcpy(vk_sequence[39][0],"");							/* Load GENERIC_FN17_KEY sequence.	*/
	strcpy(vk_sequence[40][0],"");							/* Load GENERIC_FN18_KEY sequence.	*/
	strcpy(vk_sequence[41][0],"");							/* Load GENERIC_FN19_KEY sequence.	*/
	strcpy(vk_sequence[42][0],"");							/* Load GENERIC_FN20_KEY sequence.	*/
	strcpy(vk_sequence[43][0],"");							/* Load GENERIC_FN21_KEY sequence.	*/
	strcpy(vk_sequence[44][0],"");							/* Load GENERIC_FN22_KEY sequence.	*/
	strcpy(vk_sequence[45][0],"");							/* Load GENERIC_FN23_KEY sequence.	*/
	strcpy(vk_sequence[46][0],"");							/* Load GENERIC_FN24_KEY sequence.	*/
	strcpy(vk_sequence[47][0],"");							/* Load GENERIC_FN25_KEY sequence.	*/
	strcpy(vk_sequence[48][0],"");							/* Load GENERIC_FN26_KEY sequence.	*/
	strcpy(vk_sequence[49][0],"");							/* Load GENERIC_FN27_KEY sequence.	*/
	strcpy(vk_sequence[50][0],"");							/* Load GENERIC_FN28_KEY sequence.	*/
	strcpy(vk_sequence[51][0],"");							/* Load GENERIC_FN29_KEY sequence.	*/
	strcpy(vk_sequence[52][0],"");							/* Load GENERIC_FN30_KEY sequence.	*/
	strcpy(vk_sequence[53][0],"");							/* Load GENERIC_FN31_KEY sequence.	*/
	strcpy(vk_sequence[54][0],"");							/* Load GENERIC_FN32_KEY sequence.	*/

	return(GENERIC_UNIX_TERMINAL);							/* Supported via UNIX.			*/
#else
	return(UNSUPPORTED_TERMINAL);							/* Else it is simply unsupported.	*/
#endif
}

#endif
