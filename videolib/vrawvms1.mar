;***********************************************************************
;*                                                                     *
;*          VIDEO - Video Interactive Development Environment          *
;*                                                                     *
;*                         Copyright (c) 1987                          *
;*                                                                     *
;*      An unpublished work by Greg L. Adams; all rights reserved,     *
;*                                                                     *
;***********************************************************************

	.TITLE	VRAWVMS1 -- VIDEO low level input routines
	.IDENT	/V05.00/
;+
; External Declarations:
;-
	.EXTERNAL	LIB$DISABLE_CTRL
	.EXTERNAL	LIB$ENABLE_CTRL
	.EXTERNAL	LIB$GET_EF
	.EXTERNAL	LIB$FREE_EF

	.EXTERNAL	SYS$ASSIGN
	.EXTERNAL	SYS$CANCEL
	.EXTERNAL	SYS$CLREF
	.EXTERNAL	SYS$DCLEXH
	.EXTERNAL	SYS$QIO
	.EXTERNAL	SYS$SETAST

;+
; Local Macro Definitions:
;-

	.MACRO ERROR_CHECK	STATUS_LONG, ?L1
	BLBS	STATUS_LONG, L1
	MOVL	R0, MSGBLK+4
	$PUTMSG_S	msgvec=MSGBLK
L1:	
	.ENDM	ERROR_CHECK

;+
; Equated Symbol Definitions:
;-

	$SSDEF
	$LIBDEF
	$TRMDEF
	$IODEF

DISABLE_AST	= 0			; Turns off AST delivery
ENABLE_AST	= 1			; Turns on AST delivery
BUFLEN		= 132			; **DEBUG** 132 real size

;+
; Own Storage:
;-

	.PSECT	V$DATA,	RD, WRT, NOEXE

INIT_CONST:	.LONG	^XA5A5A5A5	; An unlikely constant to use as TRUE
IO_INIT:	.LONG	0		; Flag that the channel has been assigned
INPUT_STARTED:	.LONG	0		; Flag that the input QIO has been started
WAIT_FLAG:	.LONG	0		; Wait for input completion is set
SCCA_FLAG:	.LONG	0		; Catch CTRL-C's is set.
BUF_FULL_FLAG:	.LONG	0		; When set, the ring buffer is full
BUF_CNT:	.LONG	0		; Count of how much is in the ring
CTRL_C_FLAG:	.LONG	0		; When set, indicates that a ^c was input
CHAN_INIT_FLAG:	.LONG	0		; Input channel has been assigned

EXIT_HANDLER_BLOCK:	.LONG	0
			.ADDRESS	EXIT_HANDLER
			.LONG	0	; 0 args
			.ADDRESS	EXIT_COND_VAL
EXIT_COND_VAL:		.LONG	0

VINPUT_CHAN_NUM::	.WORD	0	; The channel # returned from $ASSIGN
					; Note: this is public so other routines
					; can get the physical device info.
INPUT_CHAN_NAME:	.ASCID	/SYS$COMMAND/	; input is from SYS$COMMAND
INPUT_EF:	.LONG	0		; The EF # returned from LIB$GET_EF
INPUT_IOSB:	.BLKL	2		; The IOSB used by QIO's

INPUT_ITEMLIST:	.WORD	0		; MBZ
		.WORD	TRM$_MODIFIERS
		.LONG	<TRM$M_TM_NOECHO!TRM$M_TM_NOFILTR!TRM$M_TM_NOEDIT -
			!TRM$M_TM_NORECALL!TRM$M_TM_TRMNOECHO>
		.LONG	0		; MBZ

OLD_CTRL_MASK:	.LONG	0		; Where the old control-char mask is held
NEW_CTRL_MASK:	.LONG	LIB$M_CLI_CTRLT	; Will disable ^T reports

PUSH_BACK_CHAR:	.LONG	0		; This is where a VPUSH char goes
CHAR_BUFFER:	.LONG	0		; This is where the char input goes
CTRL_C:		.LONG	3		; This is a ^C constant

MSGBLK:		.WORD	1		; this is a msg block for the $PUTMSG
		.WORD	^X0F		;  service. what a PITA.
		.LONG	0

FETCH_P:	.LONG	0		; Points to the next char to get from ring
INSERT_P:	.LONG	0		; Where the last char input goes into ring
HEAD_P:		.ADDRESS RNGBUF		; Points to the head of the ring
TAIL_P:		.ADDRESS RNGBUF + BUFLEN	; Points to the end of the ring
RNGBUF:		.BLKB	BUFLEN

	.PSECT	V$CODE, RD, NOWRT, EXE


	.ENTRY	VIOFLAG, ^M<R2>		; Return the event flag number

	MOVL	INPUT_EF, R0
	RET


;+
;	Get single character, wait, no-echo.
;-

	.ENTRY	VRAWINPUT, ^M<R2>
	MOVL	INIT_CONST, WAIT_FLAG	; Make note that we are to wait
	BRB	V_CMN_ENTRY		;  and go check the buffers.

;+
;	Get single character, no-wait, no-echo.
;-

	.ENTRY	VRAWCHECK, ^M<R2>

	CLRL	WAIT_FLAG			; Don't wait--

V_CMN_ENTRY:
	CMPL	INIT_CONST, IO_INIT		; Have we init'ed yet?
	BEQL	5$				; Yes, go do work
	JSB	INIT_IO				; No, so do it now.

5$:	TSTL	CTRL_C_FLAG			; Was a ^C entered?
	BEQL	10$				; No, continue checking for input
	MOVL	CTRL_C, R2			; YES, get ready to return ^C char
	CLRL	CTRL_C_FLAG			; Don't do this twice for same char
	BRW	98$				; And return what we found

10$:	TSTB	PUSH_BACK_CHAR			; Was something pushed back?
	BEQL	20$				; No, go check the ring
	MOVZBL	PUSH_BACK_CHAR, R2		; Yes, so pull it out & return it.
	CLRB	PUSH_BACK_CHAR
	BRW	98$

20$:	CMPL	INIT_CONST, INPUT_STARTED	; Has initial QIO been done?
	BEQL	30$				; Yea, so go check ring
	CALLS	#0, G^START_INPUT		; No, so fire it up
	ERROR_CHECK	R0

30$:	$SETAST_S	#DISABLE_AST		; Turn off ast's, CRITCAL
;	TSTB	@FETCH_P			; Anything in ring?
	TSTL	BUF_CNT				; Anything in the ring?
	BEQL	40$				; Ring empty
	MOVZBL	@FETCH_P, R2			; Pull it out of ring
	CLRB	@FETCH_P			; Zap the byte
;	CLRL	BUF_FULL_FLAG			; We had to pull at least 1 char
	DECL	BUF_CNT
	INCL	FETCH_P                 	; Move the sniffer along
	CMPL	FETCH_P, TAIL_P			; Do we need to wrap?
	BGTRU	35$				; Yes,
	JMP	95$				; No. (Gimme a real machine)
35$:	MOVL	HEAD_P, FETCH_P			; Wrap the fetch pointer
	BRW	95$

40$:	CMPL	INIT_CONST, WAIT_FLAG		; are we 'sposed to wait?
	BEQL	41$				; Yes, So hop to it
	JMP	50$				; No, so return a null

41$:	$CLREF_S	efn=INPUT_EF		; Reset semaphore
	ERROR_CHECK	R0
	$SETAST_S	#ENABLE_AST		; Re-enable AST delivery
	ERROR_CHECK	R0
	
	.GLOBL	VR_SYNC				; call the i/o sync routine.
	PUSHL	#2
	PUSHAQ	INPUT_IOSB
	PUSHL	INPUT_EF
	CALLS	#2,G^VR_SYNC
	CLRL	WAIT_FLAG			; Don't wait any more

;	$QIO_S	chan=VINPUT_CHAN_NUM, -		; Start the input
;		efn=INPUT_EF, -
;		func=#<IO$_READVBLK!IO$M_EXTEND>, -
;		iosb=INPUT_IOSB, -
;		astadr=INPUT_AST, -
;		p1=CHAR_BUFFER, -
;		p2=#1, -
;		p5=INPUT_ITEMLIST, -
;		p6=#12

	.GLOBL	SYS$QIO
	PUSHL	#12
	PUSHAB	INPUT_ITEMLIST
	CLRQ	-(SP)
	PUSHL	#1
	PUSHAL	CHAR_BUFFER
	PUSHL	#0
	PUSHAL	INPUT_AST
	PUSHAQ	INPUT_IOSB
	MOVZWL	#<IO$_READVBLK!IO$M_EXTEND>,-(SP)
	MOVZWL	VINPUT_CHAN_NUM,-(SP)
	PUSHL	INPUT_EF
	CALLS	#12,G^SYS$QIO


	ERROR_CHECK	R0

	BRW	30$				; Go check the ring buffer again

50$:	CLRL	R2

95$:	$SETAST_S	#ENABLE_AST		; Re-enable AST delivery
	ERROR_CHECK	R0

98$:	MOVL	R2, R0				; (RO is used for cond. ret)
	RET

;+
;	Stop control C abort.
;-

	.ENTRY	XXXXYYYY_VSCCA, ^M<>

	CMPL	INIT_CONST, IO_INIT		; Was INIT_IO called?
	BEQL	1$				; Yes, so go do work
	JSB	INIT_IO				; No, assign chan first
	ERROR_CHECK	R0

1$:	CMPL	#1, (AP)			; How many args passed?
	BEQL	5$				; OK, only one was passed
	CLRL	R0				; Nope, only 1 will do.
	BRB	99$

5$:	TSTL	4(AP)				; Enable or disable?
	BNEQ	10$				; Enable ^C ast's
	CLRL	SCCA_FLAG			; else, disable them and clear
	CLRL	CTRL_C_FLAG			;  any that were queued.
	MOVL	#SS$_NORMAL, R0
	BRB	99$

10$:	TSTL	SCCA_FLAG			; Is the ^C AST already set?
	BEQL	20$				; No, so go set one.
	MOVL	#SS$_NORMAL, R0			; Yes, so don't queue 2, and just
	BRB	99$				;  exit normal.

20$:	MOVL	#1, SCCA_FLAG			; Set flag for AST to trap ^C's
	$QIO_S	chan=VINPUT_CHAN_NUM, -
		efn=INPUT_EF, -
		func=#<IO$_SETMODE!IO$M_CTRLCAST>, -
		iosb=INPUT_IOSB, -
		p1=CTRL_C_AST, -
		p3=#3				; User mode AST
	ERROR_CHECK	R0

	MOVL	#SS$_NORMAL, R0
99$:	RET

;+
;	Control C AST routine.
;-

	.ENTRY	CTRL_C_AST, ^M<>

	ERROR_CHECK	INPUT_IOSB

	BLBC	SCCA_FLAG, 98$			; If SCCA no longer on, then 
						;  don't requeue the AST
	MOVL	#1, CTRL_C_FLAG			; Else, flag ^C in input stream
	$QIO_S	chan=VINPUT_CHAN_NUM, -		; Re-queue the ^C AST
		efn=INPUT_EF, -
		func=#<IO$_SETMODE!IO$M_CTRLCAST>, -
		iosb=INPUT_IOSB, -
		p1=CTRL_C_AST, -
		p3=#3				; user mode AST
	ERROR_CHECK	R0

98$:	MOVL	#SS$_NORMAL, R0
	RET

;+
;	Normal input AST.
;-

	.ENTRY	INPUT_AST, ^M<>


	CMPL	#SS$_ABORT,INPUT_IOSB		; Are we being aborted?
	BNEQ	5$
	JMP	91$				; Yes, just skip out of here.

5$:	ERROR_CHECK	INPUT_IOSB
	CMPL	#BUFLEN, BUF_CNT		; Is BUF_CNT >= BUFLEN?
	BLEQ	80$				; Buffer full

	MOVB	CHAR_BUFFER, @INSERT_P		; No, so insert the char
	CLRB	CHAR_BUFFER			; Clean out the temp buffer
	INCL	BUF_CNT				; One more in buffer
	CMPL	INSERT_P, TAIL_P		; Do we need to wrap to head?
	BLSSU	10$				; No
	CMPL	FETCH_P, HEAD_P			; Yes, See if we just filled
	BEQLU	80$				; Ring just filled; beep
	MOVL	HEAD_P, INSERT_P		; No, we can wrap
	BRB	90$

10$:	SUBL3	#1, FETCH_P, R1			; Now see if ring was just filled
	CMPL	INSERT_P, R1
	BEQLU	80$				; Yes, we just filled it.
	INCL	INSERT_P			; No, so keep going
	BRB	90$

80$:	CALLS	#0, G^VBELL			; Ring bell to signal full ring

90$:	CMPL	INIT_CONST, WAIT_FLAG		; are we 'sposed to wait?
	BEQL	91$				; Yes, So don't issue the qio,
						; cause $synch will do it

;	$QIO_S	chan=VINPUT_CHAN_NUM, -		; Queue another char request
;		efn=INPUT_EF, -
;		func=#<IO$_READVBLK!IO$M_EXTEND>, -
;		iosb=INPUT_IOSB, -
;		astadr=INPUT_AST, -
;		p1=CHAR_BUFFER, -
;		p2=#1, -
;		p5=INPUT_ITEMLIST, -
;		p6=#12				; 12 bytes = 3 longs


	.GLOBL	SYS$QIO
	PUSHL	#12
	PUSHAB	INPUT_ITEMLIST
	CLRQ	-(SP)
	PUSHL	#1
	PUSHAL	CHAR_BUFFER
	PUSHL	#0
	PUSHAL	INPUT_AST
	PUSHAQ	INPUT_IOSB
	MOVZWL	#<IO$_READVBLK!IO$M_EXTEND>,-(SP)
	MOVZWL	VINPUT_CHAN_NUM,-(SP)
	PUSHL	INPUT_EF
	CALLS	#12,G^SYS$QIO

	ERROR_CHECK	R0

91$:	CALLS	#0, G^SIGNAL_MSG		; Signal the MESSAGE routine.
	MOVL	#SS$_NORMAL, R0
	RET

;+
;	I/O Initialization.
;-

INIT_IO:

	$ASSIGN_S	devnam=INPUT_CHAN_NAME, - ; Hookup with the input stream
			chan=VINPUT_CHAN_NUM
	ERROR_CHECK	R0

50$:	PUSHAB	OLD_CTRL_MASK			; Disable ^T status lines
	PUSHAB	NEW_CTRL_MASK
	CALLS	#2, G^LIB$DISABLE_CTRL
	ERROR_CHECK	R0

	$DCLEXH_S	desblk=EXIT_HANDLER_BLOCK	; Set up exit handler
	ERROR_CHECK	R0

	MOVL	INIT_CONST, IO_INIT		; Flag that all this has happened

 	RSB

;+
;	Exit handler
;-
	.ENTRY	EXIT_HANDLER, ^M<>

	CALLS	#0, G^VUSEREXIT			; Call the user exit routine
	CALLS	#0, G^VEXIT			; Restore the terminal to it's normal state
	PUSHAB	OLD_CTRL_MASK			; Restore previous control trapping
	CALLS	#1, G^LIB$ENABLE_CTRL
	ERROR_CHECK	R0

	$CANCEL_S	chan=VINPUT_CHAN_NUM
	ERROR_CHECK	R0

	MOVL	#SS$_NORMAL, R0
	RET

;+
;	Start input.
;-

	.ENTRY	START_INPUT, ^M<>

	MOVL	HEAD_P, FETCH_P			; Init ring pointers
	MOVL	HEAD_P, INSERT_P

	PUSHAB	INPUT_EF			; Get an event flag for use
	CALLS	#1, G^LIB$GET_EF
	ERROR_CHECK	R0

	$CANCEL_S	chan=VINPUT_CHAN_NUM	; Clean out the channel
	ERROR_CHECK	R0


;	$QIO_S	chan=VINPUT_CHAN_NUM, -		; Start the input
;		efn=INPUT_EF, -
;		func=#<IO$_READVBLK!IO$M_EXTEND>, -
;		iosb=INPUT_IOSB, -
;		astadr=INPUT_AST, -
;		p1=CHAR_BUFFER, -
;		p2=#1, -
;		p5=INPUT_ITEMLIST, -
;		p6=#12


	.GLOBL	SYS$QIO
	PUSHL	#12
	PUSHAB	INPUT_ITEMLIST
	CLRQ	-(SP)
	PUSHL	#1
	PUSHAL	CHAR_BUFFER
	PUSHL	#0
	PUSHAL	INPUT_AST
	PUSHAQ	INPUT_IOSB
	MOVZWL	#<IO$_READVBLK!IO$M_EXTEND>,-(SP)
	MOVZWL	VINPUT_CHAN_NUM,-(SP)
	PUSHL	INPUT_EF
	CALLS	#12,G^SYS$QIO
	
	ERROR_CHECK	R0

	MOVL	INIT_CONST, INPUT_STARTED	; Indicate that we were here
	MOVL	#SS$_NORMAL, R0
	RET

;+
;	Push back one character.
;-

	.ENTRY	XXXYYY_VPUSH, ^M<>

	CMPL	#1, (AP)			; How many args?
	BEQL	10$				; Just one, OK
	CLRL	R0				; More or less won't do.
	BRB	99$

10$:	TSTB	PUSH_BACK_CHAR			; Anything there yet?
	BEQL	15$                             ; No, so push it back
	CLRL	R0                              ; Yes, but push it anyway
	MOVB	4(AP), PUSH_BACK_CHAR
	BRB	99$

15$:	MOVB	4(AP), PUSH_BACK_CHAR		; Put the char away
	MOVL	#SS$_NORMAL, R0

99$:	RET

;+
;	Flush buffer.
;-

	.ENTRY	VSHUT, ^M<>

	CMPL	INIT_CONST, IO_INIT		; Have we init'ed yet?
	BEQL	5$				; Yes, go do work
	JMP	99$				; No, nothing to do then.

5$:	CMPL	INIT_CONST, INPUT_STARTED	; Has initial QIO been done?
	BEQL	10$				; Yes, go handle the close of it.
	JMP	99$				; No , just exit.

10$:	$CANCEL_S	chan=VINPUT_CHAN_NUM	; Cancel QIO's on this channel
	ERROR_CHECK	R0


	PUSHAB	INPUT_EF			; free event flag for use
	CALLS	#1, G^LIB$FREE_EF

99$:	MOVL	#0, INPUT_STARTED		; Flag that no input is in progress.
	MOVL	#SS$_NORMAL, R0
	RET

	.END
