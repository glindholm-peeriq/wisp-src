	Copyright (c) 1989-1997 by NeoMedia Technologies Inc. 
	All Rights Reserved.
	
	====================================================================
	
	Title:		WISP QA Checklist
	
	Document:	qawisp.lis
	Last Updated:	$Date:$
	Products:	WISP
	
	====================================================================

	WISP QA CHECKLIST
	=================

	QA Engineer:  _________________________________	   Date __/__/__

	Platform:     ___________________________   OS Version: __________

	WISP Version: _________________________________

	Problems 
	detected: (1)_____________________________________________________

		  (2)_____________________________________________________

		  (3)_____________________________________________________

		  (4)_____________________________________________________

		  (5)_____________________________________________________

		  (6)_____________________________________________________

		  (7)_____________________________________________________

		  (8)_____________________________________________________

		  (9)_____________________________________________________

		  (10)____________________________________________________


	PURPOSE:	This QA checklist is to be used to test and verify
			all functionality of WISP.

	WHEN USED:	This QA checklist is used everytime WISP is
			ported to a new platform and everytime a new
			release is re-ported to a platform.

+			The items that comprize a mini-test are marked
+			with a plus sign (+) in column one.

	INSTRUCTIONS:	1) Fill in the above information.

			2) Do each action in sequence and check it off
			   as it is done.

			3) If any functionality is not working number it
			   and note it on this checklist (above) and report
			   it.
			   Use the following codes beside the item:
				FAIL	- Not Working as expected
				ABORT	- Causes program to ABORT
				MISS	- Known missing functionality
				N/A	- Not Applicable to environment
				ENHC	- Enhancements needed

			4) When completed turn in this checklist.



#####################  This page is for UNIX only  ########################

+	PREREQUESITE

	___	Port WISP to this machine following the steps outlined in
		the document "portunix.lis".


+	SET UP FOR WISP QA TESTING.
	
	___	Login to 2 windows/terminals as 2 DIFFERENT userids.

	___	Set the needed environment variables

			$ WISP=/disk1/devtech/wisp 
			$ WISPGID=$$
			$ ACUDIR=/disk1/acucobol
			$ COBDIR=/disk1/mfcobol
			$ export WISP WISPGID ACUDIR COBDIR

		NOTE:	The $WISP variable must be set for the whole
			testing procedure.

	___	Change directory to your "test" dir based on the COBOL you
		are using.

		ACU	$ cd $WISP/src/testacu
		MF	$ cd $WISP/src/testmf

	___	Run the "startup" file to setup environment variables.  
		This will set your $WISPCONFIG plus COBOL specific variables.
		It will also set $QA to point to your test directory.

		ACU	$ . startup.acu
		MF	$ . startup.mf

	****
	****    THE ABOVE STEPS MUST BE DONE EVERYTIME YOU RE-START.
	****


+	SETUP $WISPCONFIG DIRECTORY

	___	Run the config setup script.

		ACU	$ configacu.sh

		MF	$ configmf.sh

	___	Check your setup with WDIAG

			$ wdiag


+	BUILD SAMPLE


	___	Build the SAMPLE programs.

		ACU	$ make -f sampleacu.umf
		MF	$ make -f samplemf.umf

	___	Build DISPRINT.

		$ cp $WISP/wisp.QA/etc/disprint.wcb .
		$ cp $WISP/wisp.QA/etc/disprint.umf .
		$ make -f disprint.umf {acu|mf}



#####################  This page is for WIN32 only  ########################

+	PREREQUESITE

	___	Port WISP to this machine following the steps outlined in
		the document "portwin32.txt".

+	SETUP $WISPCONFIG DIRECTORY

	___	Share the TESTACU directory

	___	Copy WISP\SRC\CONFIG to WISP\SRC\TESTACU\CONFIG

	___	LGMAP: cp TESTACU\LGMAP.NT to TESTACU\CONFIG\LGMAP

	___	LPMAP: Edit TESTACU\CONFIG\LPMAP and ensure that Class A
		is a valid printer.

	___	ACUCONFIG: Edit CONFIG\ACUCONFIG and add TESTACU to the
		CODE-PREFIX.

	___	WRUN.CFG: Edit CONFIG\WRUN.CFG and correct the locations
		of ACUCONFIG and WWRUNCBL.EXE.

	___	WSYSCONF.CFG: Edit CONFIG\WSYSCONF.CFG and add the machine
		name as workstation 100.

	___	WISPCONFIG: run WCONFIG and point WISPCONFIG to this
		location. ("\\SERVER\TESTACU\CONFIG")

	___	PATH: Run WCONFIG and General->PATH add

		      PATH    = ...\TESTACU\VOLRUN\ONPATH
		      MESSAGE = ...\TESTACU\MESSAGE

+	BUILD SAMPLE

	___   	SET WISPDIR=...\WISP		- set to install dir

	___	Build the SAMPLE programs.

		C:...\TESTACU> nmake /f sampleacu.mak

	___	Build DISPRINT.

		Copy DISPRINT.WCB and DISPRINT.mak from C:\WISP\ETC to the
		TESTACU directory.

		C:...\TESTACU> nmake /f disprint.mak acu


################  This page is for all platforms  ####################


+	SETUP DEFAULT USAGE CONSTANTS

	___	Run "wshell"

		Setup USAGE CONSTANTS
		(1) RUN Program or Procedure
			PROGRAM = QA0000
			LIBRARY = TESTxxx	(ACU/MF)
			VOLUME  = SOURCE

		(2) SET File Usasge Constants
		        The USAGE CONSTANTS should be set as follows:

			INLIB	= LIBIN		INVOL	= VOLIN	
			OUTLIB	= LIBOUT	OUTVOL	= VOLOUT
			RUNLIB  = LIBRUN	RUNVOL	= VOLRUN
			SPOOLLIB= #(uid)PRT	SPOOLVOL= VOLSPL
			WORKLIB	= WKxxxxxx	WORKVOL = VOLWRK

		Setup test programs
		(1) RUN Program or Procedure
			PROGRAM = QA0001
			LIBRARY = TESTxxx
			VOLUME  = SOURCE



+	First check-out general functionality.

	___     Run "wshell"
		ACU:	(1) Run QASTART in TESTACU on SOURCE
		MF:	(1) Run QASTART in TESTMF  on SOURCE

	___	REFRESH (^w)
	___	HELP-KEY (^e)
			Look for the following info:
			__  Workstation number
			__  Date and time
			__  Username
			__  System name 
			__  Progam: SAMPLE
			__  Screen: MAIN-SCREEN

	___	(32) Copyright Screen.
		Verify the Release version number.

	___	(31) Internal info
		(30) Usage Constants
		(29) Environment info

	___	(2) SET File Usage Constants.
		Verify that they are set as entered above.
		SPOOLLIB and WORKLIB should have been generated.

	___	Change SPOOLLIB = "LIBSPOOL" for rest of testing.

	___	(3) SET Print Mode defaults.
		PRNTMODE = P
		PRTCLASS = A
		FORM_NUM = 000
		Change the values then test the PF1 and RETURN options.

	___	(4) SET Submit Procedure defaults.
		JOBQUEUE = R
		JOBCLASS = A
		
	___	(5) Manage FILES/LIBRARIES

	___	AIX:  (6) Manage SYSTEM

	___	(14) PRINT PROGRAM Screen.
		(15) PRINT COMMAND Screen.
		Check the printouts for correctness.
		Files are id#### LIBSPOOL VOLSPL.
		Verify the file	has been submited to a print queue.

	___	UNIX: (7) Manage PRINT QUEUE
			If option (7) does not appear on the help screen, 
			edit the OPTIONS file in the WISPCONFIG directory 
			and uncomment the line:
				PQUNIQUE

		(9) Use UTILITIES
	___	(2) DISPLAY a file
		    FILE = XYZ     LIBRARY = LIBIN    VOLUME = VOLIN

		(9) Use UTILITIES
	___	(3) EDIT a file
		    FILE = SAMPLE  LIBRARY = TESTxxx  VOLUME = SOURCE

		(9) Use UTILITIES
	___	(4) DISPRINT
 
		(10) Configure TERMINAL.		
	___	(2)  PSEUDO Blank Characteristics.

	___	(11) Enter COMMANDS  (UNIX only)

		UNIX: 	$ ps
			$ exit  (or ^d)

	___	(13) SAVE environment.

	___	(16) CANCEL Processing

	___	(16) EXIT wshell


	Do SAMPLE.WCB tests


		$ wproc qastart		Run SAMPLE with procedure qastart

	(6) COBOL TESTS

	___	(1) DISPLAY VERB.	Should display a message.

+	___	(2) RETURN-CODE.	Enter value then exit program and
					qastart.wps will display it.

	___	(3) SORT VERB.		Will sort a small file by the 
					SORT verb, then display both
					the unsorted & sorted file.
					Verify the sorted file is sorted
					by TYPE then DATE.

	___	(4) CONDITIONAL TEST.	WISP_CODE conditions.  Press return.

+	___	(5) ACCEPT VERB.	Enter the following (TAB to fields):
					COMPANY  = This test is a trickler.
					YEARCODE = 987654321
					ACCESSCO = abc

		___	COMPANY should be 20 bytes long.  Press return.

		___	YEARCODE should be "4321".  Press return.

		___	ACCESSCODE should be "a".  Press return.

	___	(6) STOP VERB

		___	"TEST OF STOP VERB"

		___	"3"


	___	(7) MOVE WITH CONVERSION

		___    (1) Auto Test

		(PF16 to EXIT)



	(3) FILE I/O TESTS	(QAFILEIO)

		In this section we are going to test all the file I/O
		functionality.

		FILE-A tests.		Assume these work if no errors
					are reported.

+	___	(1) CREATE FILE-A AND WRITE IT		(no message)
					Should create AFILE LIBOUT VOLOUT
+	___	(4) DELETE RECORDS FROM FILE-A
+	___	(1) CREATE FILE-A AND WRITE IT
			Should get a PF3 getparm screen.
			Change FILE from AFILE to AAA and press Enter.
					Should create AAA   LIBOUT VOLOUT

		SEQUENTIAL FILE tests.

+	___	(6) CREATE A SEQUENTIAL FILE 
					Leave the lib and vol blank.
					Should create SEQFILE LIBOUT VOLOUT
		(16) back to menu.
	
	___	(22) OPEN EXTEND SEQUENTIAL (should be no getparm)
	___	(24) CLOSE SEQUENTIAL	    (no message)
	___	(23) OPEN OUTPUT SEQUENTIAL (getparm - Press PF3)
	___	(24) CLOSE SEQUENTIAL	    (no message)

+	___	(6)  (again): At PF3 option FILE=SEQFILE1
		(16) back to menu.

	___	(6) (again): Use FILE=##AB to test temp filename generation.
 		    Should use (worklib) VOLWRK. 
	___	Do the above twice each time setting FILE=##AB to test temp
 		    filename sequencing AB0000 AB0001 AB0002
	___	Once more this time don't change FILE, it should NOT give
		    you a file-getparm "PF3 to continue" because in WORKLIB.
		(16) back to menu.

+	___	(25) WRITE SEQUENTIAL	Enter any value 
					Should ERROR getparm  (85) [48][02]
							      (74) [91][02]
		(16) to EXIT program.

+	___	UNIX: 	echo $?			Should be 16
			wretcode		Should return 16



	Run SAMPLE and (3) FILE I/O TESTS

		FILE-B tests.	These test all the INDEXED file I/O operations.
				Check FILE-B-STAT field after each operation.

	___	02) Auto Test FILE-B

		This replaces a large number on manual tests.
		It creates and loads FILE-B.

		Press "ENTER" thur all of the displays until the auto
		tests are finished.  Take note of any ERRORS.


	___	15) OPEN FILE-B INPUT	Hit <RETURN>  (file status 00)
	___	17) READ NEXT		Should get 1
	___	11) WRITE FILE-B KEY=XXXX.  		        (85) [48]
								(74) [90][01]
				File status WRITE NOT ALLOWED
				There should be an ERROR getparm.
				We have declaratives but this is a BAD error.
		PF16 to EXIT program.


	Run SAMPLE and 3) FILE I/O TESTS

	___	15) OPEN FILE-B INPUT   At FILE getparm, set LIBOUT and VOLOUT
	___	15) OPEN FILE-B INPUT   Error-getparm  		(85) [41]
								(74) [92][00]
		PF16 to EXIT program.


	Run SAMPLE and 3) FILE I/O TESTS

		RECORD & FILE LOCKING TESTS
	
		FILE-B record and file locking tests. Start two windows
		running QAFILEIO. These will be referred to a <W1> & <W2>.

		**** NOTE **** If you don't have 2 windows for this
		test then only do the items marked with 3 asterisks (***).

	___	<W1> 08) OPEN FILE-B I-O  File-getparm LIBOUT VOLOUT
	___	<W2> 08) OPEN FILE-B I-O  File-getparm LIBOUT VOLOUT
					  File-getparm FILE LOCKED
	___	<W1> 10) CLOSE FILE-B
	___	<W2> RETURN to retry OPEN I-O
	___***	<W1> 09) OPEN FILE-B SHARED file-getparm FILE LOCKED

	___	<W2> 10) CLOSE FILE-B
	___	<W1> RETURN to retry OPEN SHARED
	___	<W2> 09) OPEN FILE-B SHARED  (success both have it opened)

	___***	<W2> 20) READ HOLD & REWRITE  key=AAAA (Record is now locked)
	___	<W1> 12) READ                 key=AAAA (should succeed)
	___	<W1> 19) READ HOLD            key=BBBB (should succeed)

	___***	<W1> 21) READ HOLD & DELETE   key=AAAA (should wait)
	___	<W2> Modify B-VALUE-2="NEW TEXT HERE"
		     RETURN to rewrite	  <W1> 	Should get modified record
	___	<W2> 19) READ HOLD            key=AAAA (should wait)
	___	<W1> RETURN to delete     <W2> 	file-status 23 NOT FOUND

	___	<W1> 19) READ HOLD	      key=BBBB (should succeed)
	___	<W2> 19) READ HOLD	      key=BBBB (should wait)
	___***	<W1> 29) FREE ALL         <W2> 	Should now get record
	___	<W2> 29) FREE ALL		No message

	___	<W1> 19) READ HOLD            key=BBBB	(should succeed)
	___***	<W2> 27) READ TIMEOUT         key=BBBB 
					Should wait 5 secs then come back
					with **** TIMEOUT **** filestatus 
					REC LOCKED (92 or 99 or 9D)

		Next we try a non-timeout this is tricky and you need to
		be fast. <W1> has BBBB locked now, <W2> is going to try
		to read and lock BBBB, <W1> will read and lock CCCC
		this will free BBBB and allow <W2> to lock it.

	___	<W2> 27) READ TIMEOUT key=BBBB **** don't press return ****
	___	<W1> 19) READ HOLD    key=CCCC **** don't press return ****
	___	<W2> press RETURN quickly <W1> press RETURN
		Window <W1> should get CCCC then a moment later <W2> should
		get BBBB without a TIMEOUT.

	___***	<W1> 19) READ HOLD   key=AAAA INVALID KEY 23 (was deleted)
		This should unlock CCCC.
	___	<W2> 19) READ HOLD   key=CCCC 	(should succeed)
	___***	<W2> 10) CLOSE FILE-B   	(should unlock CCCC)
	___	<W1> 19) READ HOLD   key=CCCC 	(should succeed)
	___	<W1> 10) CLOSE FILE-B

		We are finished the lock tests, EXIT from <W2>.


	QAFILEIO - Screen 2

		32) NEXT SCREEN

	___	01) SEQ/DYN LOGGING	Should give three screens, an OPEN
					WRITE and CLOSE. Each screen shows
					the file status, 05 is fine for
					the OPEN.
					Run three times waiting a minute
					between each one. This will write
					three timestamps out to the file.
	___	Now look at the file created with DISPLAY from HELP screen.
		file=@TRNSLOG lib=@LOGFIL@ vol=VOLOUT

		(Set PRINTMODE = Keep)
	___	02) OPEN OUT PRINT WRITE CLOSE
					Leave lib & vol blank, it should
					use LIBSPOOL and VOLSPL.
	___	Now look at the file created with DISPLAY from HELP screen.
		It was written with AFTER ADVANCING PAGE and 5 LINES.
		file=PRTFILE lib=LIBSPOOL vol=VOLSPL  


	___	02) OPEN OUT PRINT WRITE CLOSE (again)
					Change file=PRTFILE2.

	___	03) OPEN OUTPUT PRINT FILE	(PF3 to continue)
	___	04) CLOSE PRINT FILE		(no message)

	___	05) OPEN EXTEND PRINT FILE	(NO PF3, it's EXTEND)
	___	04) CLOSE PRINT FILE		(no message)

	___	06) OPEN EXT PRINT WRITE CLOSE	(no message, it's EXTEND)

	___	07) SUBS SCREEN/PRINT EXTEND	
			This one uses the "SCREEN" and "PRINT" subs to 
			create a print file then extend it.  You will see
			a screen image and there should be a line following
			it that has a name and timestamp.

	___	13) CREATE A LARGE FILE	  (This may take up to 10 min on VMS)
			START  __:__:__:__
			END    __:__:__:__     TIME (min:sec:hsec)  __:__:__

		PF16 to EXIT FILE I/O TESTS


	04) SCREEN I/O TESTS (QASCREEN)

		This section tests all the screen I/O functionality.

+	___	01) DISPLAY A COMPLEX SCREEN.
	___	Test the NEWLINE (^fn) & BACKTAB (^f^i) key. These keys
		are also mapped on the VT220 to NEXT-SCRN PREV-SCRN.

	___	02) TRY THE PF KEYS.  		try all PF keys 1-32
         
		03) PIC ZZ AND MISC.

		The fields on the screen will accept Alpha, Alpha-Numeric,
		or Numeric input based on the picture clauses displayed.

		Invalid values will cause the field to blink and must be
		corrected before the screen will be accepted.  After each 
		screen is accepted, press ENTER again to test the next set,
		press PF16 to exit when done.

		Numeric fields should blink if picture does not allow value.
		If fields blink, change the values and press return again.
		Enter each of the following values into every Numeric field:

	___	"0"

	___	"9.9" 

	___	"-1"   (Try   "1 CR" and "1 DB" where appropriate)

	___	Enter a value to fill the field, examples:
			PIC ----.--		-123.45
			PIC ZZZ/ZZ/ZZZZ		123456789 
			PIC ZZZZ,ZZZ,ZZZ,ZZZ	1111222333444

	___	Alpha and Alpha-Numeric fields.
		To test the Alpha and Alpha-Numeric fields, enter both valid
		and invalid Letter/Number combinations.  

+	___	06) TEST REWRITE TO CRT. 	A message should flash
       
	___	08) TEST COMPLEX MUTIPLE DIMENSIONS. (3D table)
					Just see that it displays.

		11) TEST MONKEY BAR MENU.  
	___	    TAB KEY should hit all fields
	___	    SPACEBAR should hit only menu positions   
	___	    "F" "T" "S" should take you to menu positions
	___	    ENTER at each of the menu positions should give four 
		    different screens (this tests the cursor position clause)
	___	    Move cursor off first menu position then PF16 to EXIT
		    the cursor should position back to the first menu 
		    position.
		    RETURN to continue with EXIT.

	___	12) COLUMN TEST. 	Should display column twice.
			Test the RANGE clause.
				-999   *	(* = should fail)
				-100   *
				-99
				0
				100
				999
				1000   *
				99999  *
				(blank)
                 
+		13) DISPLAY AND READ TOTAL TEST.  This tests all the clauses
		    of DISPLAY & READ. Need to run it several times.
	___	    Press PF1	message NO MODS WERE MADE ON THIS SCREEN
	___	    Rerun PF2 	message NO MODS WERE MADE ON THIS SCREEN
	___	    Rerun PF3	message ON-PFKEY: PFKEY 03 WAS PRESSED
	___	    Rerun PF4	message ON-PFKEY: PFKEY 04 WAS PRESSED

	___	    Rerun ENTER, PF5, PF16 should beep
	___	    Enter "NO " PF1  should end with no message
	___	    Rerun enter "YES" PF3 
				message ON-PFKEY: PFKEY 03 WAS PRESSED
	___	    Rerun, field should still say "NO "
	___	    Enter "XXX" PF1 & PF2 field should blink
	___	    PF3 should end with 
				message ON-PFKEY: PFKEY 03 WAS PRESSED
 
		**** NOTE ****	First change your pseudo blank to a 
				character in "N" normal rendition. 
				(something other then underline)


		15) REWRITE & READ OF CRT.   
		This does 4 rewrites & reads of the screen. The first 2
		are with the MODIFIABLE clause, the second 2 with ALTERED.
		Should be pseudo blanks in the first half of the last 2
		lines only.

		**** NOTE ****  Do not type over all of the pseudo blanks
				as we need some on the screen to test
				how the read handles them.

	___	Enter stuff on all modifiable lines. This should test all
		of the FAC's BLINK BOLD HIDDEN UNDERLINE DIM
	___	"ENTER" the pseudo blanks should be replaced with spaces.
	___	"ENTER" the pseudo blanks are back. 
	___	"ENTER" the pseudo blanks are NOT replaced with spaces.
		"ENTER" to end
     
+		17) ROW REWRITE & READ 	Test ROW oriented screen I/O
					This will write over top of the
					existing screen.
	___	At row 10 **** REWRITE TEST *** Cursor should be positioned
		at row 10 col 2.
	___	TAB should take you to row 11 col 5. This should be 
		BRITE MODIFIABLE enter text here.
	___	ENTER.
 		Row 11 should be duplicated on row 12 but DIM NO-MOD.
	___	ENTER.
		Should BEEP Row 16 message ALARM & CENTER (blinking+brite), 
		cursor should be centered on screen row 12 col 40. 
	___	ENTER.
		Cursor should postion row 1 col 40 with no other changes
		on the screen (write order-area only test). 
	___	ENTER 
		Screen should be repainted.

	___	18) MULTIPLE COLUMNS		Should display 4 double cols


	___	19) EMBEDDED FAC TEST
		    Type over the +++++ then press return. What you typed
		    should remain on screen.
		    Press return again to exit.

		PF16 to exit SCREEN tests


	05) WANG USERSUBS TESTS (QASUBS)

		This section tests all of the Wang USERSUBS.

	___	08) Link to WL0000 - AUTOMATIC QA OF VSSUBS
		Run each of the WLxxxx tests from the menu.

	___	01) WL0010  - WISPPLAT
	___	02) WL0011  - USESOFTLINK/USEHARDLINK
	___	03) WL0012  - BITPACK
	___	04) WL0013  - BITUNPK
	___	05) WL0014  - HEXPACK
	___	06) WL0015  - HEXUNPK
	___	07) WL0016  - DATE
	___	08) WL0017  - DAY
	___	09) WL0018  - MESSAGE  (Takes a few seconds to finish)
	___	10) WL0019  - SEARCH
	___	11) WL0020  - SORT
	___	12) WL0021  - STRING
	___	14) WL0023  - bit tests
	___	15) WL0024  - UPPER
	___	17) WL0025  - w2rowcol
	___	18) WL0026  - xx2byte

		(16) EXIT


	___	The WL0018A & B test the MESSAGE routine automatically.
		Each program opens a message port then they handshake and
		send and receive 100 numbered messages.

		Link to WL0018A in one session  AND...
		Link to WL0018B as a different user

		Once both programs have started, press Enter on both
		screens and they should run for a few seconds (10-15) then
		report that they sent 100 messages.
	

		01) READFDR	Try it with indexed & sequential files.

		Try with an indexed file (COMPRESSED)
		set FILE=BFILE   LIBRARY=LIBOUT VOLUME=VOLOUT

						     	UNIX	VMS
	___	Function  CD	PF2 (creation date)
	___	Function  FT	PF2 (file type)       	(I)	(I)
	___	Function  RC	PF1 (record count)    	(7)	(1)
				(Micro Focus FHISAM files don't support RC)
	___	Function  RL	PF1 (record length)   	(92)	(92)
	___	Function  RT	PF2 (record type)     	(C)  NOT SUPP & 40
	___	Function  XX    PF1   should get NOT SUPPORTED & retcode 40

		Try with an indexed file (Not COMPRESSED)
		set FILE=AAA    LIBRARY=LIBOUT VOLUME=VOLOUT

+	___	Function  RC	PF1 (record count)    	(199)	(1)
+	___	Function  RL	PF1 (record length)	(84)	(84)

		Try with an EMPTY indexed file
		set FILE=AFILE    LIBRARY=LIBOUT VOLUME=VOLOUT

+	___	Function  RC	PF1 (record count)    	(0)	(0)
+	___	Function  RT	PF2 (record type)	(F)	NOT SUPP

		Try with a sequential file
		set FILE=SEQFILE1 LIBRARY=LIBOUT VOLUME=VOLOUT

						     	UNIX	VMS
+	___	Function  FT	PF2 (file type)       	(C)	(C)
+	___	Function  RC	PF1 (record count)    	(1)	(1)
+	___	Function  RL	PF1 (record length)   	(256)	(20)
+	___	Function  BS	PF3 (Byte Size)		(120)
+	___	Function  RT	PF2 (record type)     	(V)  	NOT SUPP

		Try with an EMPTY sequential file
		set FILE=SEQFILE LIBRARY=LIBOUT   VOLUME=VOLOUT

	___	Function  RC	PF1 (record count)    	(0)	(0)

		Try with a non-existant file
		set FILE=XEQFILE LIBRARY=LIBOUT    VOLUME=VOLOUT

	___	Function  RC	PF1   should get return code 20
	___	Function  XX	PF1   should get return code 20

		UNIX: Try an UPPERCASE file name.
		set FILE=SAMPLE2  LIBRARY=LIBRUN   VOLUME=VOLRUN

	___	Function  CD	PF2 (creation date)



		02) FIND	Your going to run this several times.
				Be sure to reset the counter to 10 each time
				unless told otherwise.
				A "?" matches any number of characters
				a "*" matches one character.
				(On VMS you cannot use wildcards in the
				volume name.)
				A blank in FILE means find libraries.
				A blank in FILE & LIB means find volumes.
				COUNTER is the number returned.
				FILE COUNT is the total number found.
				STARTER is where to start returning from
				out of total number.

			****	Verify all these results against the disk.

		FILE	LIBRARY	VOLUME  START COUNTER	FILE COUNT (total)
		======  ======= ======  ===== =======	==========
	___	?	LIBOUT	VOLOUT 	1	10	(6)
+	___	A?	LIB?	VOLOUT	1	10	(2)

	___		LIB?	VOLRUN	1	10	(2)
+	___	?	?	VOLSPL	1   	10	(At least 4)
	___	?	?	VOLSPL	1   	 0	(Ditto; none shown)
	___			VOLWRK	2	10	(1 ;none shown)

	___	*FILE	LIB?	VOLOUT	1   	10	(2)
	___		LIB***	VOLRUN  1	10	(2)

	___	*FILE	LIB?	?	1   	10	(2)
	___			VOL***	1	10	(4)
	___			?	1	10	(7)
+	___	?	?	VOL?	1   	10	(many 15+)


+	___	03) PUTPARM & LINK TO DISPLAY   try with both D & E
		You can display the file XYZ in LIBIN on VOLIN.
		Just see that the PUTPARM & LINK works don't test 
		DISPLAY yet.

	___	05) GETPARM 		this tests getparmbuild, displays
					a getparm only.

+	___	06) SUBMIT  (cobol)    
			(ACU)	FILE=QABCKGRD  in TESTACU   on SOURCE
			(MF)	FILE=QABCKGRD  in TESTMF    on SOURCE

			Creates	BACK#### in LIBSPOOL on VOLSPL.
+	___		Check:  TASKTYPE=B  (in file created)
				TERMNUM=-1

			        PROGLIB=TESTxxx  PROGVOL=SOURCE

		06) SUBMIT (proc)
			        FILE=QABCKPRC   in TESTxxx   on SOURCE

	___			This will submit qabckprc.wps which will
				set
					INLIB  = QABCKPRC
					OUTLIB = Vxxxxxxx  (Task #)
				It will then run QABCKGRD twice each
				time setting RUNLIB = BKA1 then BKA2.
				Next it SUBMITS qabckpc2.wps; this sets
					INLIB  = QABCKPC2
					OUTLIB = Vxxxxxxx  (Task #)
				and runs QABCKGRD twice each time 
				setting RUNLIB = BKB1 then BKB2.

		___  The files BKA1 and BKA2 should have INLIB=QABCKPRC
		     and have the same OUTLIBs and WORKLIBs.

		___  The files BKB1 and BKB2 should have INLIB=QABCKPC2
		     and have the same OUTLIBs and WORKLIBs.

		___   The WORKLIBs should be different for BKA1 and BKB1.

	___	06) (UNIX) SUBMIT (with parameters)
		(ACU)	FILE=QABKPACU	in TESTACU	on SOURCE
		(MF)	FILE=QABKPMF	in TESTMF 	on SOURCE
		Press PF1 and enter 2 parmeters (the INVOL & OUTVOL)
			NEWIN
			NEWOUT
		The press RETURN, RETURN this will submit a script/proc
		that set INVOL to the first paramter and OUTVOL to the
		second parameter. It will then run QABCKGRD and create
			BCKP#### in LIBSPOOL on VOLSPL.

		___	See printout of BCKP#### LIBSPOOL VOLSPL and 
			verify that the	INVOL=NEWIN and OUTVOL=NEWOUT.

		___	Check your USAGE CONSTANTS to verify that they 
			didn't get changed by any of these background jobs.


		08) LINK	This will test LINK without parameters.
				(UNIX: set WISPGID=$$ if not bourne shell.)
		Link testing each LINK-TYPE

		FILE	 LIB	 VOL	 	TYPE
		=======	 ======= ======  	====
+	___	TRIGGER  (blank) (blank) 	(blank)
		PF16 to EXIT
+	___	TRIGGER2 (blank) (blank) 	(blank)	NOT FOUND (8) (20)
+	___	TRIGGER2 LIBEXE	 VOLRUN	 	P
		PF16 to EXIT
+	___	TRIGGER3 (blank) (blank) 	S
		PF16 to EXIT

		Link to a non-COBOL program.
+	___	PRTARGS			TYPE=(blank)

		Link to a shell/proc
+	___	UNIX: PRTARGSH		TYPE=(blank)

		Link with Cancel-Exit
	___	SAMPLE2  LIBRUN   VOLRUN    TYPE=P CANCEL=C
		Now go to  05) WANG USERSUBS TEST  17) LOGOFF
		this should take you to the LINK IS COMPLETE screen 
		COMP=16 

		Set CANCEL=(blank)

	___	SAMPLE2  LIBRUN   VOLRUN    TYPE=P
		Now in SAMPLE2 do a 3) FILE I/O, 24) CLOSE SEQUENTIAL
		this will cause an error-getparm, do a PF16 to EXIT
		you should arrive back in SAMPLE at LINK IS COMPLETE
		and COMPCODE = 16 

		*** Next we test LINK with parameters.

	___	FILE=SUB1  TYPE=(blank)
		In SUB1 enter 	
				LINKARG1 	AAAAA
				LINKARG2	BBBBB
				LINKARG3	CCCCC
		ENTER to LINK from SUB1 to SUB3 (SUB1 sets the CANCEL FLAG)
	___	In SUB3 the LINKARGs should have arrived.
		Modify the args
				LINKARG1 	XAAAA
				LINKARG2	XBBBB
				LINKARG3	XCCCC
		ENTER to LINK from SUB3 to SAMPLE.
		PF16 to exit SAMPLE
	___	Back in SUB3 the args should be as last modified.
		ENTER to exit SUB3 back to SUB1
	___	The args should be as modified in SUB3.
		ENTER to exit SUB1 and return to SAMPLE - LINK IS COMPLETE
		RETURN & COMP CODE should be 0

		08) LINK (with lots of parameter)
+	___	FILE=XLINK    TYPE=(blank)
		You should arrive in XLINK. 
		Next link to module=XLINK1  arg count=18  L-TYPE=(blank)
		Enter values into all 18 arguments.
+	___	ENTER should take you to XLINK1
		Ensure all args arrived.
		Modify some args.
		To go back to XLINK; set Module=(blank).
+	___	ENTER should return to XLINK.
		Ensure the modifications to the args arrived.
		To go back to SAMPLE; set Module=(blank)
+	___	ENTER should return to SAMPLE.



		09) MESSAGE	This requires two windows <W1> and <W2>.

		**** NOTE ****  If you don't have 2 windows then only do
				the tests marked with 3 asterisks (***).

	___ ***	<W1>	PORT=ABCD
			PF1 (create)	RC=0

	___		PF5 (wait)	should wait for next message

	___	<W2>	PORT=ABCD
			MESSAGE= HI THERE
			PF3 (transmit message)

	___		PF2 (destroy)	RC=8 (task didn't create port)

	___ 	<W1>	(should have recieved message)

	___ ***		PF6 (wait with timeout)  TIME=0500 (5 seconds)
					Move cursor off field
					wait 5 sec then RC=8 (timeout)

	___ ***		PORT=XBCD
			PF5 (wait)	RC=16 (no such port)

			PORT=ABCD
	___ ***		PF7 (Wait with key interrupt)
					You can now type regular keys,
					when you type an AID char (PFKey)
					cursor should jump back. 
					RC=12 (keyboard interrupt)

	___ 		PF7 (Wait with key interrupt)
					Type a couple regular keys
					(Switch to <W2>)

	___	<W2>	MESSAGE=STOP
			PF3 (transmit)	<W1> should get message and
					should stop waiting.

	___ *** <W1>	PF8 (Both Key & Time)  TIME=0500 (5 seconds)
					Type regular keys for 5 seconds
					until timeout.
					RC=8 (timeout)

	___ 		PF8 (Both Key & Time)  TIME=2000 (20 seconds)
					Type a couple regular keys
					(Switch to <W2>)

	___	<W2>	MESSAGE=BYE
			PF3 (transmit)	<W1> should get message and
					should stop waiting.

	___ ***	<W1>	PF2 (destroy)	RC=0


	Run SAMPLE & 05) WANG USERSUBS TESTS (QASUBS)


	___	Set USAGE CONSTANTS form number to 000.

		12) PRINT   file PRTFILE in LIBSPOOL on VOLSPL
	
		Do twice:

	___	PRINT_MODE=S DISPOSITION=DS (save)    COPY=3 CLASS=A
		Verify that three copies are printed and the file is
		not deleted.
	___	PRINT_MODE=S DISPOSITION=DX (scratch) COPY=1 CLASS=B
		Verify that one copy is printed and the file is deleted.

	___	13) LINKPROC 		This will link to a shell script 
					or DCL proc passing args. 
			UNIX: 	FILE=PRTARGSH  TESTxxx SOURCE
					Set up some args (remember to set 
					lengths) the first 0 length will
					terminate the list. This shell 
					script will run	the program 
					"prtargs" which will print out 
					the args and return.
			UNIX: The script does an EXIT 123 so COMPCODE=123

		14) BELL/PAUSE
	___	BELL 	PF1	1 2 5   (number of times to ring bell)
	___	PAUSE	PF2	100 500 (hunderths of seconds to pause,
					you should move your cursor out
					of the field before pressing PF2
					so you can see it pop back when
					complete.)

		15) SCRATCH
	___	F-file  PRTFILE2 in LIBSPOOL on VOLSPL
 		(check the disk)
	___	F-file  PRTFILE2 in LIBSPOOL on VOLSPL     RC=20

	___	L-Lib		    LIBSPOOL on VOLSPL     RC=0
		(check the disk)
	___	L-Lib		    LIBSPOOL on VOLSPL     RC=16

	___	F-file  LARGE    in LIBOUT   on VOLOUT     RC=0
+	___	F-file  AFILE    in LIBOUT   on VOLOUT     RC=0


		18) PUTPARM 		Using PRNAME "INPUT" you can
					issue a putparm then run DISPLAY
					to issue the getparm.

+	___	Test simple PUTPARM, cancel, and count
		Function=D  USAGE COUNT=1  FILE=AAA     PUTPARM_LABEL=AAA
		Function=D  USAGE COUNT=1  FILE=BBB
		Function=D  USAGE COUNT=1  FILE=CCC
		Function=C  USAGE COUNT=1  FILE=(blank) PUTPARM_LABEL=AAA
		PF1-DISPLAY	(file=BBB)    PF16 to exit
		PF1-DISPLAY	(file=Blank)  PF16 to exit

	___	Do two PUTPARMS then do a cancel all.
		Function=D FILE=AAA 
		Function=D FILE=BBB 
		Function=C          PUTPARM_LABEL=(blank)
		PF1-DISPLAY	(file=Blank)  PF16 to exit

		Function=E PRNAME=XXX File=CCC PUTPARM_LABEL=CCC
		Function=E PRNAME=XXX File=DDD PUTPARM_LABEL=DDD

	___	Function=R	    PUTPARM_LABEL=DDD
	___	Function=M	    PUTPARM_LABEL=DDD
	___	Function=M          PUTPARM_LABEL=CCC
	___	Function=R          PUTPARM_LABEL=CCC

	___	Function=E PRNAME=INPUT KW-CNT=0 
			   PUTPARM_LABEL=FFF REFLABEL=DDD CLEANUP=C
	___	PF1-DISPLAY	(file=DDD)  PF16 to exit
		(Reset Cleanup=blank Reflabel=blank)
	___	Function=R KW-CNT=3 PUTPARM_LABEL=FFF		(Should DDD)
	___	Function=R KW-CNT=3 PUTPARM_LABEL=DDD		(RETCODE=4)

	___	Exit and do a 	$ wputparm -l GGG ENTER INPUT FILE=ZZZ
	___			$ wputparm -a PF2 ENTER XX3 FILE=QQQ
	___			$ wputparm show

		(go back into PUTPARM tests: run SAMPLE, PF5, PF18)

	___	Function=E File=AAA Lib=AAA Vol=AAA PP_LABEL=HHH REFLABEL=GGG

	___	Function=R	PUTPARM_LABEL=HHH   (FILE=ZZZ,LIB=AAA,VOL=AAA)

		Reset PUTPARM_LABEL=(blank)
						(Set-up for next test)
		Function=E PRNAME=XX1 FILE=GETPARM1 PF-KEY=A
		Function=D PRNAME=XX2 FILE=GETPARM2 PF-KEY=@
		PF16 to EXIT PUTPARM tests


		19) GETPARM
	___	Type="I " FORM=A PRNAME=XX1	(no display PF-KEY=A)
	___	Type="I " FORM=A PRNAME=XX2	(display FILE=GETPARM2)
	___	Type="I " FORM=A PRNAME=XX3	(no display PF-KEY=B)


		24) SORTCALL/WISPSORT	This tests SORTCALL for VAX_CODE and
						  WISPSORT on ACU_CODE.
			input	BFILE   LIBOUT  VOLOUT
			output  BFILEX  LIBOUT  VOLOUT
			key1    1   1   C   A
			key2    2   1   C   D
			filetype I

	___	Display BFILEX  -  use PF11 (record size=92)
			Order should be 4, (5 or 6), 2, 3, 8, 7

			input	BFILEX  LIBOUT  VOLOUT
			output  BFILEX2 LIBOUT  VOLOUT
			key1    5   4   C   D
			key2    1   4   C   A
			filetype F reclen 92

	___	Examine BFILEX2; order should be 3, 8, 2, 7, 6, 5, 4

		WSORT utility (Do this now while fresh in your mind)
		$ wputparm clear	Clear out any stray putparms first
		$ wsort -v
			(PRNAME=INPUT)
			FILE=BFILE    LIBRARY=LIBOUT  VOLUME=VOLOUT
			FILETYPE=I   

			(PRNAME=KEYS)
			KEYS=2
			POST1=5   LENGTH1=4  TYPE1=C  ORDER1=D
			POST2=1   LENGTH1=4  TYPE1=C  ORDER1=A

			(PRNAME=OUTPUT)
			FILE=BFILEX3  LIBRARY=LIBOUT  VOLUME=VOLOUT

	___	Examine BFILEX3 it should be identical to BFILEX2
			$ display ( BFILEX3 LIBOUT VOLOUT )

		25) RENAME  *** VERIFY EACH STEP AGAINST THE DISK ****

			Set VOLUME=VOLOUT for all these tests.

		   PFKEY   FILE	    LIB	     N-FILE   N-LIB    RC
  		   ===	   ======== ======== ======== ======   ==
+	___	a) PF1 (F) SEQFILE1 LIBOUT   RN1      (blank)   0
	___	b) PF1 (F) SEQFILE1 LIBOUT   RN1      (blank)  20
	___	c) PF1 (F) RN1	    LIBOUT   (blank)  (blank)  56 
	___	d) PF3 (G) RN1	    LIBOUT   RN2      LIBRN     0
	___	e) PF2 (L) (blank)  LIBRN    (blank)  LIBXX     0
	___	f) PF3 (G) (blank)  LIBXX    (blank)  LIBRN     0
+	___	g) PF3 (G) AAA      LIBOUT   XFILE    LIBRN     0
	___	h) PF3 (G) BFILEX   LIBOUT   XFILE    LIBRN    52

		a) renames file SEQFILE1 to RN1 in LIBOUT (with F). 
		d) renames file RN1 in LIBOUT to RN2 in LIBRN (with G). 
		e) renames lib LIBRN to LIBXX (with L).
		f) renames lib LIBXX to LIBRN (with G).
		g) renames an indexed file (for cisam 2 part files)
		h) renames file to an existing file (should fail)


+	___	27) READVTOC
			OPTION=F    LIBRARY=LIBOUT   VOLUME=VOLOUT

	___	28) FILECOPY
			OLD=	BFILE	LIBOUT  VOLOUT
			NEW=	COPY    LIBRN   VOLOUT

+	___	29) WSXIO

		___	3) WSXIO WRITE READ AID
		___	6) WSXIO READ TIMED(10) AID
		___	9) WSXIO UPDATE

	___	31) COBLINK  	Does a LINK type " " and if file is not
				found will then do a LINK of type "S".

				On UNIX so be sure your PATH includes your 
				current dir.

+		___	COBLINK to TRIGGER  (PF-16) (Type=" " current dir)
		___	COBLINK to TRIGGER3 (PF-16) (Type="S" on the PATH)


	___	Link to WL0022 to auto-test  - SET/EXTRACT

+	___	17) LOGOFF		This should really logoff.	


	___	Log back on and resetup you environment.

		UNIX: 	$ WISP=/usrxxx/wisp export WISP
			$ WISPGID=$$ export WISPGID
			$ cd $WISP/src/testxxx
			$ . startup.xxx
			$ wrun SAMPLE


	07) PRINTING TESTS (SAMPLE)

		1) CREATE A PRINT FILE	Creates file PRFILE LIBSPOOL VOLSPL
			Do this once for each of the following tests each
			time go to HELP and change your print constants.

		      MODE CLASS FORM
+	___		S    A    000	Should print & delete
+	___		H    A	  000	Should hold
+	___		K    A    000	Getparm - change to PRFILE2
+	___		P    B    000	Getparm - change to PRFILE3 class=Z


		Set MODE = P

	___	2) CREATE TEMP PRINT FILE (ADVANCING & OVERSTRIKE)
					TST####  in LIBSPOOL on VOLSPL

	___	3) CREATE A PRINT FILE WITH MULTIPLE OVERSTRIKES
					OVERSTRK in LIBSPOOL on VOLSPL

	___	5) ZERO LENGTH PRINT FILE
					ZERO#### in LIBSPOOL on VOLSPL
					Should not print a empty file.

	___	6) NO NAME PRINT FILE
					samp####   in LIBSPOOL on VOLSPL


	UTILITIES

		This section tests all of the Utilities.
		NOTE: Not all of these are available on all platforms.

	wusage

+	___	wusage version
	___	wshell			Give Command Processor
	___	wusage write		Write PERSONALITY

	___	UNIX: wusage extract SPOOLIB
					Should get LIBSPOOL

	___	wusage set SPOOLIB=TSTSPOOL
	___	UNIX: wusage extract SPOOLIB
					Should get TSTSPOOL

	___	wusage read			Read PERSONALITY
	___	UNIX: wusage extract SPOOLIB
					Should get LIBSPOOL

	___	wusage flags		Set the following to "N"
						SET File Usage Constants
						Enter COMMANDS
						SAVE environment
	___	wshell			The above should be missing.
	___	wusage flags set help=n
	___	run SAMPLE and try to entry HELP (^e) should beep
	___	wusage flags [verify:	Help Screen			N
					SET File Usage Constants	N
					Enter COMMANDS			N
					SAVE environment		N
		Set all flags to Y

+	___	wshell		        All options should be back

+	___	PF1 RUN		PROGRAM=SAMPLE

		PF16	- exit SAMPLE
		PF16	- exit wusage


	display

	___	display	 Should getparm  LIBIN VOLIN  (PF16 to exit)
+	___	UNIX: display .../volin/libin/xyz
					Should go directly to display
					On UNIX stays in 80 col mode.
	___	HELP (^e)		Menu
+	___	PF3			Bottom of file
+	___	PF2			Top of file
	___	PF3  + Interrupt before done by pressing any key
	___	PF5			Next screen
	___	PF4			Prev screen

+	___	PF7			Find -enter a string the exists
	___	PF1			Home Cursor
	___	PF8			Find Next (repeat until end)
	___	PF2			Top
	___	PF7			Find -enter a non-extent string
	___	PF2			Top
	___	PF8  + Interrupt before done

	___	PF10			Scroll right (several times)
	___	PF9			Scroll left
	___	PF6			Switch to 132 & back

+	___	PF14			Print screen
	___	PF15			Print file

	___	PF11			Change records size
	___	PF12			Show position
	___	PF13			Stream mode

	___	PF16			EXIT


	wcopy

	___	INPUT:	FILE	BFILE	LIBOUT	VOLOUT
		OUTPUT		BCOPY	LIBOUT2 VOLOUT

	___	INPUT	LIBRARY		LIBIN	VOLIN
		OUTPUT			LIBIN2	VOLIN

	wputparm
		(UNIX: you must be using /bin/sh or set WISPGID=$$)

+	___	wputparm ENTER INPUT -c 3 FILE=XYZ LIB=MYLIB VOL=VOL100
		wputparm DISPLAY OUTPUT -a PF1 FILE=ABC
		wputparm ENTER PRINT -l PRINT FILE=##FRED
		wputparm SHOW		this should show the above

+	___	wputparm CLEAR -l PRINT
		wputparm SHOW		the ENTER PRINT one should be gone

+	___	wputparm CLEAR
		wputparm SHOW		All should be gone.

+	___	wputparm ENTER SEQFIL -l SEQFIL		test backward ref

+	___	run SAMPLE 
			3) FILE I/O TEST
			6) CREATE SEQUENTIAL FILE 
				FILE=##TMP		create temp file
			EXIT from SAMPLE

+	___	wputparm SHOW			Should have KEEP
+	___	UNIX: wputparm GET FILE -l SEQFIL

+	___	wputparm DISPLAY INPUT -l NEW -r SEQFIL
		display		- get values from reflabel SEQFIL
		wputparm show	- new putparm with same values as SEQFIL
		wputparm clear




#####################  This page is for UNIX only  ####################

	WISP License

+	___	wlicense
		run SAMPLE			no "unlicensed" message


	wsubmit
	___	wsubmit QABCKGRD TESTxxx SOURCE
				file=BACK#### lib=LIBSPOOL vol=VOLSPL

	viewkey
	___	viewkey

	vcapkeys
	___	vcapkeys	Build a videocap file and test it.


	wdelwrk

	___	wdelwrk		should delete current worklib

	___	su				Remove all worklibs
		rm -r -f `cat /usr/tmp/WLIBLIST`
		rm /usr/tmp/WLIBLIST
		
	wrun
	___	wrun				should give runcbl & options
		RUNCBL=xyz export RUNCBL
	___	wrun -b -w -?			should "xyz -b -w"
		unset RUNCBL 			set RUNCBL back

	___	wrun SUB3 using AA BB CC	should start SUB3 with args

	================================================================

		TO TEST wcopy, wexists, wrename, wscratch run qautils.sh
	___	qautils.sh	(perform the following tests)

	================================================================

	wcopy	(old style)
	   __	wcopy XYZ LIBIN VOLIN XXX LIBIN VOLIN	  same lib
		echo $?				should be 0
	   __	wcopy QQQ LIBIN VOLIN XXX LIBIN VOLIN	  non-extent file
		echo $?				should be 20
	   __	wcopy XYZ LIBIN VOLIN XYZ NEWLIB VOLOUT	  make a new lib
		echo $?				should be 0
	   __	wcopy library NEWLIB VOLOUT NEWLIB VOLIN  copy a lib
		echo $?				should be 0

	wexists
	   __	wexists file XYZ LIBIN VOLIN
		echo $?				should be 0  (exists)
	   __	wexists file QQQ LIBIN VOLIN
		echo $?				should be 1  (not found)
	   __	wexists library LIBIN VOLIN
		echo $?				should be 0
	   __	wexists library QQQQ VOLIN	
		echo $?				should be 1
	   __	wexists volume VOLIN	
		echo $?				should be 0
	   __	wexists volume QQQQ		
		echo $?				should be 1


	wrename
	   __	wrename XYZ NEWLIB VOLOUT NEW NEWLIB
	   __	wrename NEW NEWLIB VOLOUT NEW2 NEWLIB2
		echo $?				should be 0 (success)
	   __	wrename NEW NEWLIB VOLOUT NEW2 NEWLIB2
		echo $?				should be 20 (not found)
	   __	wrename library NEWLIB2 VOLOUT NEWLIB3

	wscratch
	   __	wscratch NEW2 NEWLIB3 VOLOUT
		echo $?				should be 0
	   __	wscratch NEW2 NEWLIB3 VOLOUT
		echo $?				should be 20
	   __	wscratch library NEWLIB3 VOLOUT
		echo $?				should be 0
	   __	wscratch library NEWLIB3 VOLOUT
		echo $?				should be 16

	================================================================

	___	ipcs				Check whats out there
		wsysinit -v			Must be ROOT (SU)
		ipcs				Should be cleaned-up
		ls /usr/tmp			Temp files should be gone


	================================================================

	Return to PORTUNIX.LIS

	================================================================
